#! /usr/bin/env perl

#-----------------------------------------------------------------------------
# POD Format Documentation.  Read "perldoc perlpod" for an example.
# When done, check syntax with "podchecker".

=head1 NAME

testit - A little test driver.

=head1 SYNOPSIS

testit [--help] --no-fatal [--just tcname] [--optimize] [--no-debug] [--clean] [--outdir dir] [--driverpath dir] [--lldebug]

=head1 DESCRIPTION

This used to be the testsuite, but now just runs a single test.  The testsuite orchestration has been moved to ctest.

Options:

=over 4

=item --driverpath dir

Where to run silly from.

=item --outdir dirname

Will be created with 'mkdir -p' if it doesn't exist.

=item --no-fatal

Warn, insted of die, on error.

=item --just testname

Run only testname.  Given full source test.silly, say, this is the test file stem test.

=item --no-debug

Do not pass -g to compiler.

=item --optimize

Pass -O 2 to compiler.

=item --lldebug

Pass the llvm/mlir --debug option to the silly driver.

=back

=head1 SUPPORTED PLATFORMS

 Unix (Linux verified)

=head1 SUPPORT

 Send email to peeterjoot@pm.me

=head1 AUTHORS

 Peeter Joot

=cut

#-----------------------------------------------------------------------------

use strict ;
use warnings ;
use Getopt::Long ;
use Pod::Usage ;

# Suppress sourcing of users' .bashrc files in invoked shells
delete $ENV{'ENV'} ;
delete $ENV{'BASH_ENV'} ;

# Set STDOUT and STDERR to unbuffered
select STDERR ; $| = 1 ;
select STDOUT ; $| = 1 ;

my $myName = '' ;

($myName = $0) =~ s@.*[/\\]@@ ;
my $fatal = 1;
my $just;
my $optimize = 0;
my $debug = 1;
my $lldebug = 0;
my $clean = 0;
my $assembly = 1;
my $outdir;
my $driverpath;

#Getopt::Long::Configure( 'pass_through' ) ;
GetOptions (
   'help'               => sub { pod2usage(-verbose => 2) ; },
   'fatal!'             => \$fatal,
   'just=s'             => \$just,
   'outdir=s'           => \$outdir,
   'driverpath=s'       => \$driverpath,
   'optimize!'          => \$optimize,
   'assembly!'          => \$assembly,
   'debug!'             => \$debug,
   'lldebug!'           => \$lldebug,
   'clean!'             => \$clean,
) or pod2usage(-verbose => 0) ;

# Validate/handle options, and everything else...

# normalize input:
if ( defined $just )
{
    $just =~ s/\.silly$//;
    $just =~ s/\.sir$//;
}

if ( !defined $driverpath )
{
    my $TOP = `git rev-parse --show-toplevel 2>/dev/null`; chomp $TOP;
    $driverpath = "${TOP}/build/bin";
}

my $flags = '';

if ( $optimize )
{
    $flags .= ' -O 2';
}

if ( $debug )
{
    $flags .= ' -g';
}

if ( $lldebug )
{
    $flags .= ' --debug';
}

if ( !defined $outdir )
{
    $outdir = 'out'
}

if ( $clean )
{
    system( qq(rm -rf $outdir) );
}

my %testflags = (
    'arrayprod' => '--init-fill 255',
    'initlist' => '--init-fill 255',
    'initarray' => '--init-fill 255',
);

my %decl_order_tests =
(
    'two_declare_no_init' => 'a,b',
);

# The test list is moved to tests/endtoend/CMakeLists.txt -- this is now just for --just
my %tests = map { $_ => 1 } (qw(
));
#error_nonconst_init -- want this to be a compile error, but it isn't yet.

#error_zero_step_for -- infinite loops.  would be better to have runtime check for that and abort.
#error_invalid_unary -- regression. was triggering on y undeclared, not on the parse error -- which doesn't actually drive a compile error!
#error_intarray_bad_constaccess
#error_array_oob_const -- dup?
#error_decl_in_if -- probably want this to fail (like scopebug)
#error_decl_in_elif_else -- probably also want this to fail too.
#'error_invalid_unary' => q(line 3:4 token recognition error at:),
my %expected_compile_error_message =
(
  'error_arrayreturn' => [
    q(error_arrayreturn.silly:1:24: error: parse error: mismatched input '[' expecting '{'), ],
  'error_array_too_many_init' => [
    q(error_array_too_many_init.silly:1:1: error: For variable 'a', more initializers (4) specified than number of elements (3).), ],
  'error_chained_comparison2' => [
    q(error_chained_comparison2.silly:4:16: error: parse error: mismatched input '<' expecting ';'), ],
  'error_chained_equality' => [
    q(error_chained_equality.silly:2:17: error: parse error: mismatched input 'EQ' expecting ';'), ],
  'error_expressions4c' => [
    q(error_expressions4c.silly:1:13: error: parse error: mismatched input '<' expecting ';'), ],
  'error_expressions4d' => [
    q(error_expressions4d.silly:1:14: error: parse error: mismatched input 'EQ' expecting ';'), ],
  'error_expressions4e' => [
    q(error_expressions4e.silly:1:14: error: parse error: mismatched input 'NE' expecting ';'), ],
  'error_get_string' => [
    q(error_get_string.silly:2:1: error: Attempted GET to string literal or array?), ],
  'error_induction_var_in_step' => [
    q(error_induction_var_in_step.silly:1:23: error: Undeclared variable i), ],
  'error_init_list1' => [
    q(error_init_list1.silly:1:1: error: For variable 'w', more initializers (3) specified than number of elements (1).), ],
  'error_init_list2' => [
    q(error_init_list2.silly:1:1: error: For variable 'w', more initializers (3) specified than number of elements (2).), ],
  'error_invalid_binary' => [
    q(error_invalid_binary.silly:3:9: error: parse error: extraneous input 'z' expecting ';'), ],
  'error_keyword_declare2' => [
    q(error_keyword_declare2.silly:1:7: error: parse error: extraneous input 'INT32' expecting IDENTIFIER), ],
  'error_keyword_declare' => [
    q(error_keyword_declare.silly:1:7: error: parse error: mismatched input 'INT32' expecting IDENTIFIER), ],
  'error_multiple_in_func' => [
    q(error_multiple_in_func.silly:5:15: error: Undeclared variable x),
    q(error_multiple_in_func.silly:6:15: error: Undeclared variable w), ],
  'error_nested_ivar_conflict' => [
    q(error_nested_ivar_conflict.silly:3:5: error: Induction variable i used by enclosing FOR), ],
  'error_nested' => [
    q(error_nested.silly:5:5: error: Nested functions are not currently supported.), ],
  'error_notfloat' => [
    q(error_notfloat.silly:1:7: error: NOT on non-integer type), ],
  'error_redeclare' => [
    q(error_redeclare.silly:2:1: error: Variable x already declared), ],
  'error_return_expr_no_return_type' => [
    q(error_return_expr_no_return_type.silly:3:5: error: return expression found '0', but no return type for function foo), ],
  'error_shadow_induction' => [
    q(error_shadow_induction.silly:4:1: error: Induction variable i clashes with declared variable), ],
  'error_stringreturn' => [
    q(error_stringreturn.silly:1:19: error: parse error: mismatched input 'STRING' expecting {'INT8', 'INT16', 'INT32', 'INT64', 'FLOAT32', 'FLOAT64', 'BOOL'}), ],
  'error_triple_nested_for_with_shadowing' => [
    q(error_triple_nested_for_with_shadowing.silly:3:9: error: Induction variable i used by enclosing FOR), ],
  'error_undeclare' => [
    q(error_undeclare.silly:1:1: error: Attempt to assign to undeclared variable: x), ],
);

if ( defined $just )
{
    $tests{$just}++ unless ( defined $tests{$just} );
}

my %expectedRC = (
   'bool' => 1,
   'int32' => 1,
   'boolr' => 1,
   'exit3' => 3,
   'exit42' => 42,
   'exitx' => 3,
   'exitarrayelement' => 42,
   'fatal' => 134, # abort
   'getboolfail' => '134', # abort
);

my %expectedInput = (
    'get' => '6 7 1 2 3 4 5',
    'getbool' => '0 1',
    'getboolfail' => '2',
);

my @warnings = ();

sub verbose_system
{
    my ($cmd) = @_;

    print "# $cmd\n";
    system( $cmd );

    return $? >> 8;
}

my $pwd = `pwd` ; chomp $pwd;

runone( $just );

if ( scalar( @warnings ) )
{
    print "ERRORS:\n\n";

    foreach ( @warnings )
    {
        warn $_;
    }
}

exit 0;

sub runone
{
    my ($stem) = @_;

    print "##########################################################################\n";
    verbose_system( qq(cat $stem.silly) );

    my $thisflags = $flags;

    if ( defined $testflags{$stem} )
    {
        #$thisflags .= " $testflags{$stem}";
    }

    print "##########################################################################\n";
    my $source;
    if ( -e "$stem.sir" )
    {
        $source = "$stem.sir";
    }
    else
    {
        $source = "$stem.silly";
    }

    my $cmd = qq(mkdir -p $outdir ; ${driverpath}/silly --output-directory $outdir $source $thisflags --emit-llvm --emit-mlir > ${outdir}/$stem.compile.out 2>&1);
    my $crc = verbose_system( $cmd );
    system("cat ${outdir}/$stem.compile.out");
    if ( defined $expected_compile_error_message{$stem})
    {
        # check output for 'PLEASE submit a bug report' -- make that an error:
        my $hasstack = `grep "PLEASE submit a bug report" ${outdir}/$stem.compile.out` ; chomp $hasstack;
        if ( $hasstack ne '' )
        {
            print "TEST: $stem.silly failed, but with internal error\n";
            return;
        }

        if ($crc)
        {
            print "TEST: $stem.silly failed as expected: rc = $crc\n";

            my @expected = @{$expected_compile_error_message{$stem}};
            foreach ( @expected )
            {
                check_expected_compile_error( $stem, $_, "${outdir}/$stem.compile.out" );
            }

            print "${stem}: TEST WAS SUCCESSFUL\n"; # for ctest rule
        }
        else
        {
            die "Expected failure running $stem.silly";
        }

        return;
    }

    verbose_system( qq(objdump -dr --no-show-raw-insn ${outdir}/${stem}.o > ${outdir}/${stem}.s) );

    if ( $assembly )
    {
        verbose_system( qq(cat ${outdir}/${stem}.s) );
    }

    my $rc;
    my $exe = "${outdir}/${stem}";
    unless ( $exe =~ m,^[/\.], )
    {
        $exe = "./$exe";
    }

    if ( defined $expectedInput{${stem}} ) {
        $rc = verbose_system( qq(echo "$expectedInput{${stem}}" | ${exe} > ${outdir}/${stem}.out 2>${outdir}/${stem}.stderr.out) );
    } else {
        $rc = verbose_system( qq(${exe} > ${outdir}/${stem}.out 2>${outdir}/${stem}.stderr.out) );
    }
    verbose_system( qq(echo 'stdout:' ; cat ${outdir}/${stem}.out) );
    verbose_system( qq(echo 'stderr:' ; cat ${outdir}/${stem}.stderr.out) );

    print "${stem}: returned: $rc\n\n\n\n\n";

    my $erc = $expectedRC{$stem};
    if ( !defined $erc )
    {
        $erc = 0;
    }

    complain( "${stem}: expected $erc, and got $rc" ) if ( $rc ne $erc );

    if ( -e "expected/${stem}.out" )
    {
        my $crc = verbose_system( qq(diff -wup expected/${stem}.out ${outdir}/${stem}.out) );
        complain( "ERROR: diff -wup expected/${stem}.out ${outdir}/${stem}.out: $crc\n") if ( $crc );
    }
    else
    {
        my $msg = "ERROR: COMPARE FILE NOT FOUND: expected/${stem}.out\n";
        push( @warnings, $msg );
    }

    if ( -e "expected/${stem}.stderr.out" )
    {
        my $crc = verbose_system( qq(diff -wup expected/${stem}.stderr.out ${outdir}/${stem}.stderr.out) );
        complain( "ERROR: diff -wup expected/${stem}.stderr.out ${outdir}/${stem}.stderr.out: $crc\n") if ( $crc );
    }

    # DI testing HACK for one issue, now fixed:
    if ( $stem eq 'f' )
    {
        # Could check a lot more, but start with this:
        my $cmd = qq(dwarfdump ${outdir}/f.o | tee ${outdir}/f.dd | grep -A3 DW_AT_linkage_name.*bar0 | tail -1);
        my $line = `$cmd` ; chomp $line;

        unless ( $line =~ /DW_AT_decl_line.*0x00000003/ )
        {
            complain( "ERROR: unexpected dwarfdump output for f.silly in ${outdir}/f.dd.  Expected DW_AT_decl_line 0x00000003, found: '$line'" );
        }
    }

    if ( $stem eq 'for_simplest' )
    {
        # Could check a lot more, but start with this:
        my $cmd = qq(dwarfdump ${outdir}/for_simplest.o | tee ${outdir}/for_simplest.dd | grep -A3 'DW_AT_name.*myLoopVar' | tail -1);
        my $line = `$cmd` ; chomp $line;

        unless ( $line =~ /DW_AT_decl_line.*0x00000003/ )
        {
            complain( "ERROR: unexpected dwarfdump output for for_simplest.silly (variable myLoopVar) in ${outdir}/for_simplest.dd.  Expected DW_AT_decl_line 0x00000003, found: '$line'" );
        }
    }

    if ( defined $decl_order_tests{$stem} )
    {
        check_decl_order( "${outdir}/${stem}.mlir", $decl_order_tests{$stem} );
    }

    print "${stem}: TEST WAS SUCCESSFUL\n"; # for ctest rule
}

sub complain
{
    my ($message) = @_;

    if ( $fatal )
    {
        die $message;
    }
    else
    {
        push( @warnings, $message );
    }
}

sub check_decl_order
{
    my ($mlir_file, $expected_str) = @_;

    die "MLIR file not found: $mlir_file" unless (-f $mlir_file);
    open my $fh, '<', $mlir_file or die "Cannot open $mlir_file: $!\n";

    my @found;
    while (my $line = <$fh>) {
        if ($line =~ /sym_name\s*=\s*"([^"]+)"/) {
            push @found, $1;
        }
    }
    close $fh;

    my @expected = split /,/, $expected_str;

    if (@found != @expected) {
        complain(sprintf("wrong number of declarations in %s (got %d, expected %d)\nFound: %s\nExpected: %s",
                         $mlir_file, scalar(@found), scalar(@expected),
                         join(", ", @found), join(", ", @expected)));
        return;
    }

    for my $i (0 .. $#expected) {
        if ($found[$i] ne $expected[$i]) {
            complain(sprintf("declaration order mismatch in %s at position %d: expected '%s', got '%s'\nFull sequence: %s",
                             $mlir_file, $i+1, $expected[$i], $found[$i],
                             join(", ", @found)));
            return;
        }
    }

    # print "OK: $mlir_file declarations in order: ", join(", ", @found), "\n";
}

sub check_expected_compile_error
{
    my ($stem, $expected, $outfile) = @_;

    open my $fh, '<', $outfile
        or die "Cannot open $outfile: $!";

    local $/;
    my $output = <$fh>;
    close $fh;

    if ( index($output, $expected) >= 0 )
    {
        print "Matched expected error message for $stem: found: '$expected'\n";
        return;
    }

    complain(qq(
Expected compile error not found for ${stem}.silly

Expected substring:
${expected}

Actual output:
${output}
));
}

# vim: et ts=4 sw=4
