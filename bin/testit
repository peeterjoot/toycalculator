#! /usr/bin/env perl

#-----------------------------------------------------------------------------
# POD Format Documentation.  Read "perldoc perlpod" for an example.
# When done, check syntax with "podchecker".

=head1 NAME

testit - A little test driver.

=head1 SYNOPSIS

testit [--help] --no-fatal [--just tcname] [--optimize] [--no-debug] [--clean] [--outdir dir] [--driverpath dir] [--lldebug]

=head1 DESCRIPTION

This used to be the testsuite, but now just runs a single test.  The testsuite orchestration has been (mostly) moved to ctest.

Options:

=over 4

=item --driverpath dir

Where to run silly from.

=item --outdir dirname

Will be created with 'mkdir -p' if it doesn't exist.

=item --no-fatal

Warn, insted of die, on error.

=item --just testname

Run only testname.  Given full source test.silly, say, this is the test file stem test.

=item --no-debug

Do not pass -g to compiler.

=item --optimize

Pass -O 2 to compiler.

=item --lldebug

Pass the llvm/mlir --debug option to the silly driver.

=back

=head1 SUPPORTED PLATFORMS

 Unix (Linux verified)

=head1 SUPPORT

 Send email to peeterjoot@pm.me

=head1 AUTHORS

 Peeter Joot

=cut

#-----------------------------------------------------------------------------

use strict ;
use warnings ;
use Getopt::Long ;
use Pod::Usage ;

# Suppress sourcing of users' .bashrc files in invoked shells
delete $ENV{'ENV'} ;
delete $ENV{'BASH_ENV'} ;

# Set STDOUT and STDERR to unbuffered
select STDERR ; $| = 1 ;
select STDOUT ; $| = 1 ;

my $myName = '' ;

($myName = $0) =~ s@.*[/\\]@@ ;
my $fatal = 1;
my $just;
my $optimize = 0;
my $debug = 1;
my $lldebug = 0;
my $clean = 0;
my $assembly = 1;
my $outdir;
my $driverpath;

#Getopt::Long::Configure( 'pass_through' ) ;
GetOptions (
   'help'               => sub { pod2usage(-verbose => 2) ; },
   'fatal!'             => \$fatal,
   'just=s'             => \$just,
   'outdir=s'           => \$outdir,
   'driverpath=s'       => \$driverpath,
   'optimize!'          => \$optimize,
   'assembly!'          => \$assembly,
   'debug!'             => \$debug,
   'lldebug!'           => \$lldebug,
   'clean!'             => \$clean,
) or pod2usage(-verbose => 0) ;

# Validate/handle options, and everything else...

# normalize input:
if ( defined $just )
{
    $just =~ s/\.silly$//;
    $just =~ s/\.sir$//;
}

if ( !defined $driverpath )
{
    my $TOP = `git rev-parse --show-toplevel 2>/dev/null`; chomp $TOP;
    $driverpath = "${TOP}/build/bin";
}

my $flags = '';

if ( $optimize )
{
    $flags .= ' -O 2';
}

if ( $debug )
{
    $flags .= ' -g';
}

if ( $lldebug )
{
    $flags .= ' --debug';
}

if ( !defined $outdir )
{
    $outdir = 'out'
}

if ( $clean )
{
    verbose_system( qq(rm -rf $outdir) );
}

my %decl_order_tests =
(
    'two_declare_no_init' => 'a,b',
);

my %tests = ();

die if ( !defined $just ); # now required.

$tests{$just}++ unless ( defined $tests{$just} );

my @warnings = ();

sub verbose_system
{
    my ($cmd) = @_;

    print "# $cmd\n";
    system( $cmd );

    return $? >> 8;
}

my $pwd = `pwd` ; chomp $pwd;

runone( $just );

if ( scalar( @warnings ) )
{
    print "ERRORS:\n\n";

    foreach ( @warnings )
    {
        warn $_;
    }
}

exit 0;

sub runone
{
    my ($stem) = @_;

    print "##########################################################################\n";
    verbose_system( qq(cat $stem.silly) );

    my $thisflags = $flags;

    print "##########################################################################\n";
    my $source;
    if ( -e "$stem.sir" )
    {
        $source = "$stem.sir";
    }
    else
    {
        $source = "$stem.silly";
    }

    verbose_system("mkdir -p $outdir ; rm -f ${outdir}/${stem}.compile.out ${outdir}/${stem}.ll ${outdir}/${stem}.mlir ${outdir}/${stem}.o ${outdir}/${stem}.out ${outdir}/${stem}.s ${outdir}/${stem}.stderr.out ${outdir}/${stem}.dd");

    my $cmd = qq(${driverpath}/silly --output-directory $outdir $source $thisflags --emit-llvm --emit-mlir > ${outdir}/$stem.compile.out 2>&1);
    my $crc = verbose_system( $cmd );
    verbose_system("cat ${outdir}/$stem.compile.out");

    verbose_system( qq(objdump -dr --no-show-raw-insn ${outdir}/${stem}.o > ${outdir}/${stem}.s) );

    if ( $assembly )
    {
        verbose_system( qq(cat ${outdir}/${stem}.s) );
    }

    my $rc;
    my $exe = "${outdir}/${stem}";
    unless ( $exe =~ m,^[/\.], )
    {
        $exe = "./$exe";
    }

    $rc = verbose_system( qq(${exe} > ${outdir}/${stem}.out 2>${outdir}/${stem}.stderr.out) );
    verbose_system( qq(echo 'stdout:' ; cat ${outdir}/${stem}.out) );
    verbose_system( qq(echo 'stderr:' ; cat ${outdir}/${stem}.stderr.out) );

    print "${stem}: returned: $rc\n\n\n\n\n";

    complain( "${stem}: expected 0, and got $rc" ) if ( $rc ne 0 );

    if ( -e "expected/${stem}.out" )
    {
        my $crc = verbose_system( qq(diff -wup expected/${stem}.out ${outdir}/${stem}.out) );
        complain( "ERROR: diff -wup expected/${stem}.out ${outdir}/${stem}.out: $crc\n") if ( $crc );
    }
    else
    {
        my $msg = "ERROR: COMPARE FILE NOT FOUND: expected/${stem}.out\n";
        push( @warnings, $msg );
    }

    if ( -e "expected/${stem}.stderr.out" )
    {
        my $crc = verbose_system( qq(diff -wup expected/${stem}.stderr.out ${outdir}/${stem}.stderr.out) );
        complain( "ERROR: diff -wup expected/${stem}.stderr.out ${outdir}/${stem}.stderr.out: $crc\n") if ( $crc );
    }

    # DI testing HACK for one issue, now fixed:
    if ( $stem eq 'f' )
    {
        # Could check a lot more, but start with this:
        my $cmd = qq(dwarfdump ${outdir}/f.o | tee ${outdir}/f.dd | grep -A3 DW_AT_linkage_name.*bar0 | tail -1);
        my $line = `$cmd` ; chomp $line;

        unless ( $line =~ /DW_AT_decl_line.*0x00000003/ )
        {
            complain( "ERROR: unexpected dwarfdump output for f.silly in ${outdir}/f.dd.  Expected DW_AT_decl_line 0x00000003, found: '$line'" );
        }
    }

    if ( $stem eq 'for_simplest' )
    {
        # Could check a lot more, but start with this:
        my $cmd = qq(dwarfdump ${outdir}/for_simplest.o | tee ${outdir}/for_simplest.dd | grep -A3 'DW_AT_name.*myLoopVar' | tail -1);
        my $line = `$cmd` ; chomp $line;

        unless ( $line =~ /DW_AT_decl_line.*0x00000003/ )
        {
            complain( "ERROR: unexpected dwarfdump output for for_simplest.silly (variable myLoopVar) in ${outdir}/for_simplest.dd.  Expected DW_AT_decl_line 0x00000003, found: '$line'" );
        }
    }

    if ( defined $decl_order_tests{$stem} )
    {
        check_decl_order( "${outdir}/${stem}.mlir", $decl_order_tests{$stem} );
    }

    print "${stem}: TEST WAS SUCCESSFUL\n"; # for ctest rule
}

sub complain
{
    my ($message) = @_;

    if ( $fatal )
    {
        die $message;
    }
    else
    {
        push( @warnings, $message );
    }
}

sub check_decl_order
{
    my ($mlir_file, $expected_str) = @_;

    die "MLIR file not found: $mlir_file" unless (-f $mlir_file);
    open my $fh, '<', $mlir_file or die "Cannot open $mlir_file: $!\n";

    my %ssa_to_name;      # Maps SSA value (e.g., "%0") to variable name
    my @declare_order;    # Order in which declares appear

    while (my $line = <$fh>) {
        # Match declare: %0 = "silly.declare"() : () -> !silly.var<i32>
        if ($line =~ /^\s*(%\d+)\s*=\s*"silly\.declare"/) {
            my $ssa_val = $1;
            push @declare_order, $ssa_val;
        }
        # Match debug_name: "silly.debug_name"(%0) <{name = "a"}>
        elsif ($line =~ /"silly\.debug_name"\((%\d+)\)\s*<\{name\s*=\s*"([^"]+)"\}>/) {
            my $ssa_val = $1;
            my $var_name = $2;
            $ssa_to_name{$ssa_val} = $var_name;
        }
    }
    close $fh;

    # Build the ordered list of variable names based on declare order
    my @found;
    for my $ssa_val (@declare_order) {
        if (exists $ssa_to_name{$ssa_val}) {
            push @found, $ssa_to_name{$ssa_val};
        } else {
            complain("Declaration $ssa_val has no corresponding debug_name in $mlir_file");
            return;
        }
    }

    my @expected = split /,/, $expected_str;

    if (@found != @expected) {
        complain(sprintf("wrong number of declarations in %s (got %d, expected %d)\nFound: %s\nExpected: %s",
                         $mlir_file, scalar(@found), scalar(@expected),
                         join(", ", @found), join(", ", @expected)));
        return;
    }

    for my $i (0 .. $#expected) {
        if ($found[$i] ne $expected[$i]) {
            complain(sprintf("declaration order mismatch in %s at position %d: expected '%s', got '%s'\nFull sequence: %s",
                             $mlir_file, $i+1, $expected[$i], $found[$i],
                             join(", ", @found)));
            return;
        }
    }

    # print "OK: $mlir_file declarations in order: ", join(", ", @found), "\n";
}

# vim: et ts=4 sw=4
