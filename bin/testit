#!/usr/bin/perl

#-----------------------------------------------------------------------------
# POD Format Documentation.  Read "perldoc perlpod" for an example.
# When done, check syntax with "podchecker".

=head1 NAME

testit - A little test driver.

=head1 SYNOPSIS

testit [--help] --no-fatal [--just tcname] [--optimize] [--no-debug]

=head1 DESCRIPTION

Options:

=over 4

=item --no-fatal

Warn, insted of die, on error.

=item --just testname

Run only testname.  Given full source test.silly, say, this is the test file stem test.

=item --no-debug

Do not pass -g to compiler.

=item --optimize

Pass -O 2 to compiler.

=back

=head1 SUPPORTED PLATFORMS

 Unix (Linux verified)

=head1 SUPPORT

 Send email to peeterjoot@pm.me

=head1 AUTHORS

 Peeter Joot

=cut

#-----------------------------------------------------------------------------

use strict ;
use warnings ;
use Getopt::Long ;
use Pod::Usage ;

# Suppress sourcing of users' .bashrc files in invoked shells
delete $ENV{'ENV'} ;
delete $ENV{'BASH_ENV'} ;

# Set STDOUT and STDERR to unbuffered
select STDERR ; $| = 1 ;
select STDOUT ; $| = 1 ;

my $myName = '' ;

($myName = $0) =~ s@.*[/\\]@@ ;
my $fatal = 1;
my $just;
my $optimize = 0;
my $debug = 1;
my $assembly = 1;

#Getopt::Long::Configure( 'pass_through' ) ;
GetOptions (
   'help'               => sub { pod2usage(-verbose => 2) ; },
   'fatal!'             => \$fatal,
   'just=s'             => \$just,
   'optimize!'          => \$optimize,
   'assembly!'          => \$assembly,
   'debug!'             => \$debug,
) or pod2usage(-verbose => 0) ;

# Validate/handle options, and everything else...

# normalize input:
if ( defined $just )
{
    $just =~ s/\.silly$//;
}

my $flags = '';

if ( $optimize )
{
    $flags .= ' -O 2';
}

if ( $debug )
{
    $flags .= ' -g';
}

system( qq(rm -rf out) );

my %testflags = (
    'arrayprod' => '--init-fill 255',
    'initlist' => '--init-fill 255',
    'initarray' => '--init-fill 255',
);

my %decl_order_tests =
(
    'two_declare_no_init' => 'a,b',
);

my %tests = map { $_ => 1 } (qw(
0minus
a2
addi
andop
array
array_assign_and_use
array_dynamic_index
array_elem_as_arg
array_in_comparison
array_index_var
array_in_expr
array_in_expr_min
array_lvalue_complex
array_mixed_type
arrayprod
assign_to_array_complex
bin
bool
bool_arith_mixed
boolcall0
boolcall1
boolcall2
bool_in_arith
boolliteral
bool_not_on_comparison
boolop
boolr
call_in_predicate
call_with_param_referenced
chained_comparison_parens
const_overflow
conversions
converti
dcl
div_zero_float
div_zero_int
elif
elif2
elif3
elif4
elif5
elif6
empty
eqop
exit3
exit42
exitarrayelement
exitx
expressions1
expressions2
expressions3
expressions4
expressions4a
expressions4b
expressions5
expressions6
expressions_assignment
expressions_in_call
expressions_in_for
expressions_in_if
f
factorial
factorial2
fatal
foo
for_complex_body
for_simplest
forward_ref_init
function
function_add
function_foo_with_local
function_intret_intparam
function_intret_void
function_plist
function_plist_nocast
function_return
function_two
function_void_intparm
function_void_void
get
getbool
getboolfail
if
ifdcl
induction_not_used
init
initarray
init_expr_bool
init_expr_call
init_expr_unary
initlist
initlist_param
initlisttrunc
inits
initsequence
initstring
intarray
lessbug
lessbug2
lessbug3
lesseqop
lessop
loadstore
longstring
minimal_eliftest
minmax
mixed_type_assignment
neg
negative_step_for
neqop
nested_calls
nested_for
nested_if_basic
nested_if_deep
nested_if_elif_else
not
not_on_expr
orop
printboollit
printcont
printdi
printdi_nested
printexpr
printlit
print_multiple
printsome
return_complex
return_expression
s2
scopebug
shortstring
shortstring2
shortstring3
simpleless
simplest
stringlit
test
two_declare_no_init
types
unary
unary_on_array_elem
xorop
zero_iter_for
));
#error_nonconst_init -- want this to be a compile error, but it isn't yet.

my %failuretests = map {$_ => 1} (qw(
error_arrayreturn
error_array_too_many_init
error_chained_comparison2
error_chained_equality
error_expressions4c
error_expressions4d
error_expressions4e
error_induction_var_in_step
error_init_list1
error_init_list2
error_invalid_binary
error_keyword_declare
error_keyword_declare2
error_nested_ivar_conflict
error_notfloat
error_redeclare
error_return_expr_no_return_type
error_shadow_induction
error_stringreturn
error_triple_nested_for_with_shadowing
error_undeclare
));
#error_zero_step_for -- infinite loops.  would be better to have runtime check for that and abort.
#error_invalid_unary -- regression. was triggering on y undeclared, not on the parse error -- which doesn't actually drive a compile error!
#error_intarray_bad_constaccess
#error_array_oob_const -- dup?
#error_decl_in_if -- probably want this to fail (like scopebug)
#error_decl_in_elif_else -- probably also want this to fail too.

my %expected_compile_error_message =
(
  'error_induction_var_in_step' => q(error: Undeclared variable i (symbol lookup failed.)),
  'error_triple_nested_for_with_shadowing' => q(error: Induction variable i used by enclosing FOR:),
  'error_shadow_induction' => q(error: Induction variable i clashes with declared variable in:),
  'error_nested_ivar_conflict' => 'Induction variable i used by enclosing FOR',
  'error_arrayreturn' => 'Syntax error in error_arrayreturn.silly:1',
  'error_array_too_many_init' => q(error: For variable 'a', more initializers (4) specified than number of elements (3)),
  'error_chained_comparison2' => q(Syntax error in error_chained_comparison2.silly:4:15: mismatched input '<' expecting ';' (token: < )),
  'error_chained_equality' => q(Syntax error in error_chained_equality.silly:2:16: mismatched input 'EQ' expecting ';' (token: EQ )),
  'error_expressions4c' => q(Syntax error in error_expressions4c.silly:1:12: mismatched input '<' expecting ';' (token: < )),
  'error_expressions4d' => q(Syntax error in error_expressions4d.silly:1:13: mismatched input 'EQ' expecting ';' (token: EQ )),
  'error_expressions4e' => q(Syntax error in error_expressions4e.silly:1:13: mismatched input 'NE' expecting ';' (token: NE )),
  'error_init_list1' => q(error: For variable 'w', more initializers (3) specified than number of elements (1).),
  'error_init_list2' => q(error: For variable 'w', more initializers (3) specified than number of elements (2).),
  'error_invalid_binary' => q(Syntax error in error_invalid_binary.silly:3:8: extraneous input 'z' expecting ';' (token: z )),
  'error_invalid_unary' => q(line 3:4 token recognition error at: ),
  'error_keyword_declare' => q(Syntax error in error_keyword_declare.silly:1:6: mismatched input 'INT32' expecting IDENTIFIER (token: INT32 )),
  'error_keyword_declare2' => q(Syntax error in error_keyword_declare2.silly:1:6: extraneous input 'INT32' expecting IDENTIFIER (token: INT32 )),
  'error_notfloat' => q(error: NOT on non-integer type),
  'error_redeclare' => q(error: Variable x already declared),
  'error_return_expr_no_return_type' => q(error: return expression found '0', but no return type for function foo),
  'error_stringreturn' => q(Syntax error in error_stringreturn.silly:1),
  'error_undeclare' => q(error: Attempt to assign to undeclared variable: x=3),
);

if ( defined $just )
{
    $tests{$just}++ unless ( defined $tests{$just} );
}

my %expectedRC = (
   'bool' => 1,
   'boolr' => 1,
   'exit3' => 3,
   'exit42' => 42,
   'exitx' => 3,
   'exitarrayelement' => 42,
   'fatal' => 134, # abort
   'getboolfail' => '134', # abort
);

my %expectedInput = (
    'get' => '6 7 1 2 3 4 5',
    'getbool' => '0 1',
    'getboolfail' => '2',
);

my @warnings = ();

sub verbose_system
{
    my ($cmd) = @_;

    print "# $cmd\n";
    system( $cmd );

    return $? >> 8;
}

my $pwd = `pwd` ; chomp $pwd;
my @alltests = keys %tests;
push(@alltests, keys %failuretests);

foreach my $stem (sort @alltests)
{
    next if ( $stem =~ /^#/ );
    next if ( defined $just and $just ne $stem );

    print "##########################################################################\n";
    verbose_system( qq(cat $stem.silly) );

    my $thisflags = $flags;

    if ( defined $testflags{$stem} )
    {
        #$thisflags .= " $testflags{$stem}";
    }

    print "##########################################################################\n";
    my $cmd = qq(mkdir -p out ; ../build/silly --output-directory out $stem.silly $thisflags --emit-llvm --emit-mlir > out/$stem.compile.out 2>&1);
    my $crc = verbose_system( $cmd );
    system("cat out/$stem.compile.out");
    if ( defined $failuretests{$stem} )
    {
        if ($crc)
        {
            print "TEST: $stem.silly failed as expected: rc = $crc\n";

            if ( $expected_compile_error_message{$stem} )
            {
                check_expected_compile_error( $stem, "out/$stem.compile.out" );
            }
        }
        else
        {
            die "Expected failure running $stem.silly";
        }

        next;
    }

    verbose_system( qq(objdump -dr --no-show-raw-insn out/${stem}.o > out/${stem}.s) );

    if ( $assembly )
    {
        verbose_system( qq(cat out/${stem}.s) );
    }

    my $rc;
    if ( defined $expectedInput{${stem}} ) {
        $rc = verbose_system( qq(echo "$expectedInput{${stem}}" | ./out/${stem} > out/${stem}.out 2>out/${stem}.stderr.out) );
    } else {
        $rc = verbose_system( qq(./out/${stem} > out/${stem}.out 2>out/${stem}.stderr.out) );
    }
    verbose_system( qq(echo 'stdout:' ; cat out/${stem}.out) );
    verbose_system( qq(echo 'stderr:' ; cat out/${stem}.stderr.out) );

    print "${stem}: RC = $rc\n\n\n\n\n";

    my $erc = $expectedRC{$stem};
    if ( !defined $erc )
    {
        $erc = 0;
    }

    complain( "stem: $rc != $erc" ) if ( $rc ne $erc );

    if ( -e "expected/${stem}.out" )
    {
        my $crc = verbose_system( qq(diff -wup expected/${stem}.out out/${stem}.out) );
        complain( "ERROR: diff -wup expected/${stem}.out out/${stem}.out: $crc\n") if ( $crc );
    }
    else
    {
        my $msg = "ERROR: COMPARE FILE NOT FOUND: expected/${stem}.out\n";
        push( @warnings, $msg );
    }

    if ( -e "expected/${stem}.stderr.out" )
    {
        my $crc = verbose_system( qq(diff -wup expected/${stem}.stderr.out out/${stem}.stderr.out) );
        complain( "ERROR: diff -wup expected/${stem}.stderr.out out/${stem}.stderr.out: $crc\n") if ( $crc );
    }

    # DI testing HACK for one issue, now fixed:
    if ( $stem eq 'f' )
    {
        # Could check a lot more, but start with this:
        my $cmd = qq(dwarfdump out/f.o | tee out/f.dd | grep -A3 DW_AT_linkage_name.*bar0 | tail -1);
        my $line = `$cmd` ; chomp $line;

        unless ( $line =~ /DW_AT_decl_line.*0x00000003/ )
        {
            complain( "ERROR: unexpected dwarfdump output for f.silly in out/f.dd.  Expected DW_AT_decl_line 0x00000003, found: '$line'" );
        }
    }

    if ( $stem eq 'for_simplest' )
    {
        # Could check a lot more, but start with this:
        my $cmd = qq(dwarfdump out/for_simplest.o | tee out/for_simplest.dd | grep -A3 'DW_AT_name.*myLoopVar' | tail -1);
        my $line = `$cmd` ; chomp $line;

        unless ( $line =~ /DW_AT_decl_line.*0x00000003/ )
        {
            complain( "ERROR: unexpected dwarfdump output for for_simplest.silly (variable myLoopVar) in out/for_simplest.dd.  Expected DW_AT_decl_line 0x00000003, found: '$line'" );
        }
    }

    if ( defined $decl_order_tests{$stem} )
    {
        check_decl_order( "out/${stem}.mlir", $decl_order_tests{$stem} );
    }
}

if ( scalar( @warnings ) )
{
    print "ERRORS:\n\n";

    foreach ( @warnings )
    {
        warn $_;
    }
}

exit 0;

sub complain
{
    my ($message) = @_;

    if ( $fatal )
    {
        die $message;
    }
    else
    {
        push( @warnings, $message );
    }
}

sub check_decl_order
{
    my ($mlir_file, $expected_str) = @_;

    die "MLIR file not found: $mlir_file" unless (-f $mlir_file);
    open my $fh, '<', $mlir_file or die "Cannot open $mlir_file: $!\n";

    my @found;
    while (my $line = <$fh>) {
        if ($line =~ /sym_name\s*=\s*"([^"]+)"/) {
            push @found, $1;
        }
    }
    close $fh;

    my @expected = split /,/, $expected_str;

    if (@found != @expected) {
        complain(sprintf("wrong number of declarations in %s (got %d, expected %d)\nFound: %s\nExpected: %s",
                         $mlir_file, scalar(@found), scalar(@expected),
                         join(", ", @found), join(", ", @expected)));
        return;
    }

    for my $i (0 .. $#expected) {
        if ($found[$i] ne $expected[$i]) {
            complain(sprintf("declaration order mismatch in %s at position %d: expected '%s', got '%s'\nFull sequence: %s",
                             $mlir_file, $i+1, $expected[$i], $found[$i],
                             join(", ", @found)));
            return;
        }
    }

    # print "OK: $mlir_file declarations in order: ", join(", ", @found), "\n";
}

sub check_expected_compile_error
{
    my ($stem, $outfile) = @_;

    my $expected = $expected_compile_error_message{$stem}
        or return;   # nothing to check

    open my $fh, '<', $outfile
        or die "Cannot open $outfile: $!";

    local $/;
    my $output = <$fh>;
    close $fh;

    if ( index($output, $expected) >= 0 )
    {
        print "Matched expected error message for $stem\n";
        return;
    }

complain(qq(
Expected compile error not found for ${stem}.silly

Expected substring:
${expected}

Actual output:
${output}
));
}

# vim: et ts=4 sw=4
