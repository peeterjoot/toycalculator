///
/// @file ParseListener.hpp
/// @author Peeter Joot <peeterjoot@pm.me>
/// @brief Antlr4 based Listener and MLIR builder for the silly compiler.
///
/// This class processes the parse tree generated by the Silly grammar, building
/// corresponding MLIR operations in the Silly dialect. It tracks variable states
/// per function, handles scoping, control flow (if/for), declarations, assignments,
/// function calls, and built-in operations (print/get/exit/return).
///
#pragma once
#include <antlr4-runtime.h>
#include <mlir/Dialect/Func/IR/FuncOps.h>
#include <mlir/IR/Builders.h>
#include <mlir/IR/BuiltinOps.h>
#include <mlir/IR/MLIRContext.h>

#include <format>
#include <map>
#include <string>
#include <unordered_map>
#include <vector>

#include "DriverState.hpp"
#include "MlirTypeCache.hpp"
#include "PrintFlags.hpp"
#include "SillyBaseListener.h"
#include "SillyDialect.hpp"

namespace silly
{
    /// Per-function state tracked during parsing.
    class ParserPerFunctionState
    {
       public:
        /// Default constructor
        ParserPerFunctionState();

        /// Getter for op, just to hide the casting
        mlir::func::FuncOp getFuncOp()
        {
            mlir::func::FuncOp funcOp{};
            if ( op )
            {
                funcOp = mlir::cast<mlir::func::FuncOp>( op );
            }

            return funcOp;
        }

        /// Setter for op, matching getFuncOp (which hides the casting)
        void setFuncOp( mlir::Operation *funcOp )
        {
            op = funcOp;
        }

        /// Search the inductionVariables stack for the named variable.
        ///
        /// This variable is pushed in enterForStatement, and popped in exitForStatement.
        inline mlir::Value searchForInduction( const std::string &varName );

        /// Add the mlir::Value for a named FOR loop variable to inductionVariables stack.
        inline void pushInductionVariable( const std::string &varName, mlir::Value i );

        /// Remove the top-most name/value pair from the inductionVariables stack.
        inline void popInductionVariable();

        /// Search parameters for the named variable.
        inline mlir::Value searchForParameter( const std::string &varName );

        /// Search variables for the named variable.
        inline mlir::Value searchForVariable( const std::string &varName );

        /// Add the mlir::Value for a parameter variable to the parameter list.
        inline void recordParameterValue( const std::string &varName, mlir::Value i );

        /// Add the mlir::Value for a variable variable to the variable list.
        inline void recordVariableValue( const std::string &varName, mlir::Value i );

        /// Is there an insertion point stack yet for this function?
        bool haveInsertionPointStack();

        /// Add to the insertion point stack for this function.
        void pushToInsertionPointStack( mlir::Operation *op );

        /// Remove last insertion point from the stack for this function.
        void popFromInsertionPointStack( mlir::OpBuilder &builder );

        /// Location of the last declaration for this function
        ///
        /// Declarations will all be inserted back to back before the function body statements.
        mlir::Operation *getLastDeclared()
        {
            return lastDeclareOp;
        }

        /// Set this operation (a declaration) as the last one for this function.
        void setLastDeclared( mlir::Operation *op )
        {
            lastDeclareOp = op;
        }

        /// New variables will be visible only for this scope and later
        inline void startScope();

        /// Any variables that had been declared in the current scope will no longer be visible.
        inline void endScope();

       private:
        /// The last silly::DeclareOp created for the current function.
        ///
        /// The next declaration in the function will be placed after this, and
        /// this point updated accordingly.
        mlir::Operation *lastDeclareOp;

        /// Associated func::FuncOp.
        mlir::Operation *op;

        /// Induction variable name to Value mapping type
        using ValueList = std::vector<std::pair<std::string, mlir::Value>>;

        /// Variable and parameter name to Value mapping type
        using ValueMap = std::unordered_map<std::string, mlir::Value>;

        /// FOR loop variable stack containing all such variables that are in scope.
        ValueList inductionVariables;

        /// Parameter name/value pairs.
        ValueMap parameters;

        /// Variable name/value pairs.
        std::vector<ValueMap> variables;

        /// Stack for scf.if/scf.for blocks.
        std::vector<mlir::Operation *> insertionPointStack;
    };

    /// Start and end locations associated with parser context.
    using LocPairs = std::pair<mlir::Location, mlir::Location>;

    /// antlr4::tree::TerminalNode is a long winded expression
    using tNode = antlr4::tree::TerminalNode;

    /// ANTLR listener that constructs MLIR for the Silly language.
    ///
    /// Inherits from SillyBaseListener and BaseErrorListener to process parse tree
    /// events and report syntax errors. Builds a ModuleOp containing FuncOps
    /// with Silly dialect operations.
    class ParseListener : public SillyBaseListener, public antlr4::BaseErrorListener
    {
       public:
        /// Constructor.
        /// @param ds [in,out] Driver state (for emitUserError, emitInternalError)
        /// @param filename [in] Source filename for this module (used to construct Location info)
        /// @param context [in] The context under which the mlir module is created.
        ParseListener( DriverState &ds, const std::string &filename, mlir::MLIRContext *context );

        /// Open the file stream, and walk the parse tree.
        ///
        /// Will set DriverState::openFailed for early pre-parse stream open error (with nullptr return.)
        ///
        /// If DriverState::openFailed is false, then a non-nullptr return means that no compilation errors occured, and
        /// the MLIR builder was successful.  FIXME: need a sema pass.  That should happen after this builder return.
        ///
        mlir::OwningOpRef<mlir::ModuleOp> run();

        /// Override to throw on syntax errors.
        void syntaxError( antlr4::Recognizer *recognizer, antlr4::Token *offendingSymbol, size_t line,
                          size_t charPositionInLine, const std::string &msg, std::exception_ptr e ) override;

        /// Antlr4 enter hook for the start rule.
        void enterStartRule( SillyParser::StartRuleContext *ctx ) override;

        /// Antlr4 exit hook for the start rule.
        void exitStartRule( SillyParser::StartRuleContext *ctx ) override;

        /// Antlr4 entry hook for the scopedStatements rule.
        void enterScopedStatements( SillyParser::ScopedStatementsContext *ctx ) override;

        /// Antlr4 exit hook for the scopedStatements rule.
        void exitScopedStatements( SillyParser::ScopedStatementsContext *ctx ) override;

        /// Antlr4 enter hook for an IF statement
        void enterIfStatement( SillyParser::IfStatementContext *ctx ) override;

        /// Antlr4 enter hook for an ELIF statement
        void enterElifStatement( SillyParser::ElifStatementContext *ctx ) override;

        /// Antlr4 enter hook for an ELSE statement
        void enterElseStatement( SillyParser::ElseStatementContext *ctx ) override;

        /// Antlr4 exit hook for an IF-ELIF-ELSE statement.
        ///
        /// Restore EXACTLY where we were before creating the scf.if
        /// This places new ops right AFTER the scf.if
        void exitIfElifElseStatement( SillyParser::IfElifElseStatementContext *ctx ) override;

        /// Antlr4 enter hook for a functionStatement rule.
        void enterFunctionStatement( SillyParser::FunctionStatementContext *ctx ) override;
        /// Antlr4 exit hook for a functionStatement rule.
        void exitFunctionStatement( SillyParser::FunctionStatementContext *ctx ) override;

        /// Antlr4 enter hook for a callStatement rule.
        void enterCallStatement( SillyParser::CallStatementContext *ctx ) override;

        /// Antlr4 enter hook for a returnStatement rule.
        void enterReturnStatement( SillyParser::ReturnStatementContext *ctx ) override;

        /// Antlr4 enter hook for a boolDeclareStatement rule.
        void enterBoolDeclareStatement( SillyParser::BoolDeclareStatementContext *ctx ) override;

        /// Antlr4 enter hook for an intDeclareStatement rule.
        void enterIntDeclareStatement( SillyParser::IntDeclareStatementContext *ctx ) override;

        /// Antlr4 enter hook for a floatDeclareStatement rule.
        void enterFloatDeclareStatement( SillyParser::FloatDeclareStatementContext *ctx ) override;

        /// Antlr4 enter hook for a stringDeclareStatement rule.
        void enterStringDeclareStatement( SillyParser::StringDeclareStatementContext *ctx ) override;

        /// Antlr4 enter hook for a printStatement rule.
        void enterPrintStatement( SillyParser::PrintStatementContext *ctx ) override;

        /// Antlr4 enter hook for an errorStatement rule.
        void enterErrorStatement( SillyParser::ErrorStatementContext *ctx ) override;

        /// Antlr4 enter hook for an abortStatement rule.
        void enterAbortStatement( SillyParser::AbortStatementContext *ctx ) override;

        /// Antlr4 enter hook for a getStatement rule.
        void enterGetStatement( SillyParser::GetStatementContext *ctx ) override;

        /// Antlr4 enter hook for a forStatement rule.
        void enterForStatement( SillyParser::ForStatementContext *ctx ) override;

        /// Antlr4 exit hook for a forStatement rule.
        void exitForStatement( SillyParser::ForStatementContext *ctx ) override;

        /// Antlr4 enter hook for an assignmentStatement rule.
        void enterAssignmentStatement( SillyParser::AssignmentStatementContext *ctx ) override;

        /// Antlr4 enter hook for an exitStatement rule.
        void enterExitStatement( SillyParser::ExitStatementContext *ctx ) override;

       private:
        /// Source filename, ...
        DriverState &driverState;

        const std::string &sourceFile;

        /// Context for all the loaded dialects.
        mlir::MLIRContext *ctx;

        /// MLIR builder.
        mlir::OpBuilder builder;

        /// Top-level module.
        mlir::OwningOpRef<mlir::ModuleOp> mod;

        /// mlir::Type values that will be used repeatedly
        MlirTypeCache typ;

        /// Saved insertion point for main.
        mlir::OpBuilder::InsertPoint mainIP{};

        /// Current function name.
        std::string currentFuncName;

        /// Per-function state map.
        std::unordered_map<std::string, std::unique_ptr<ParserPerFunctionState>> functionStateMap;

        /// Syntax errors detected.  Return a nullptr Module if this is non-zero.
        int errorCount{};

        /// By default silly programs have a main ('MAIN;' at start is implied.)  If, instead
        /// of MAIN (implicit or explicit), a 'MODULE;' is specified, that source may have
        /// only FUNCTIONs.
        bool isModule{};

        ////////////////////////////////////////////////////////////////////////
        ///
        /// Helper functions
        ///
        ////////////////////////////////////////////////////////////////////////

        /// Emit a user-friendly error message in GCC/Clang style
        ///
        /// (calls emitError)
        void emitUserError( mlir::Location loc, const std::string &message, const std::string &funcName )
        {
            emitError( loc, message, funcName, false );
        }

        /// Emit an internal error message, including the location in the compiler source where the error occured.
        ///
        /// (calls emitError)
        void emitInternalError( mlir::Location loc, const char *compilerfile, unsigned compilerline,
                                const char *compilerfunc, const std::string &message,
                                const std::string &programFuncName );

        /// Internal parse listener error message output.
        ///
        /// Show the file:line:col: error: message (colorized if desired.)
        ///
        /// errorCount is incremented as a side effect.
        void emitError( mlir::Location loc, const std::string &message, const std::string &funcName, bool internal );

        /// Lookup in per-function state, whether a variable has been declared
        bool isVariableDeclared( const std::string &varName );

        /// @brief check for inappropriate RETURN
        ///
        /// Grammar now allows for RETURN in IF/ELIF/ELSE/FOR blocks, (as well as FUNCTION)
        /// but that is not supported.  Check for that explicitly, and raise a user error,
        /// instead of just letting this fail mysteriously in lowering.
        void checkForReturnInScope( SillyParser::ScopedStatementsContext *scope, const char *what );

        /// Create a silly::ArithBinOp
        inline mlir::Value createBinaryArith( mlir::Location loc, silly::ArithBinOpKind what, mlir::Type ty,
                                              mlir::Value lhs, mlir::Value rhs );

        /// Create a silly::CmpBinOp
        inline mlir::Value createBinaryCmp( mlir::Location loc, silly::CmpBinOpKind what, mlir::Value lhs,
                                            mlir::Value rhs );

        /// Lookup and validate a declareStatement variable name, and process the declaration.
        void enterDeclareHelper( mlir::Location loc, tNode *identifier,
                                 SillyParser::DeclareAssignmentExpressionContext *declareAssignmentExpression,
                                 const std::vector<SillyParser::ExpressionContext *> &expressions, tNode *hasInitList,
                                 SillyParser::ArrayBoundsExpressionContext *arrayBoundsExpression, mlir::Type ty );

        /// Looks up DeclareOp for a variable.
        silly::DeclareOp lookupDeclareForVar( mlir::Location loc, const std::string &varName );

        /// Construct locations from the getStart() and getStop() tokens.
        /// Side effect: Creates a silly::ScopeOp for main, if not already done.
        inline LocPairs getLocations( antlr4::ParserRuleContext *ctx );

        /// Computes start location from parser context.
        /// Side effect: Creates a silly::ScopeOp for main, if not already done.
        inline mlir::Location getStartLocation( antlr4::ParserRuleContext *ctx );

        /// Computes stop location from parser context.
        /// Side effect: Creates a silly::ScopeOp for main, if not already done.
        inline mlir::Location getStopLocation( antlr4::ParserRuleContext *ctx );

        /// Build a Location for an antlr4 Token.
        inline mlir::Location getTokenLocation( antlr4::Token *token );

        /// Build a Location for an antlr4 tNode
        inline mlir::Location getTerminalLocation( tNode *node );

        /// Strip double quotes off of a string, and build a string literal op for it
        silly::StringLiteralOp buildStringLiteral( mlir::Location loc, const std::string &input );

        /// Creates a silly::ScopeOp and initializes function state.
        void createScope( mlir::Location startLoc, mlir::Location endLoc, mlir::func::FuncOp func,
                          const std::string &funcName, const std::vector<std::string> &paramNames );

        /// Emits a CallOp for a function call.
        mlir::Value handleCall( SillyParser::CallExpressionContext *ctx );

        /// builder logic for print arguments (shared between PRINT and ERROR.)
        void handlePrint( mlir::Location loc, const std::vector<SillyParser::ExpressionContext *> &args,
                          const std::string &errorContextString, PrintFlags flags );

        /// Registers a variable declaration in the current scope.
        void registerDeclaration( mlir::Location loc, const std::string &varName, mlir::Type ty,
                                  SillyParser::ArrayBoundsExpressionContext *arrayBounds,
                                  SillyParser::ExpressionContext *assignmentExpression,
                                  const std::vector<SillyParser::ExpressionContext *> *expressions );

        /// Construct a Value for a TRUE or FALSE boolean literal string
        inline mlir::Value parseBoolean( mlir::Location loc, const std::string &s );

        /// Construct a Value for an integer literal string
        inline mlir::Value parseInteger( mlir::Location loc, int width, const std::string &s );

        /// Construct a Value for a floating point literal string
        inline mlir::Value parseFloat( mlir::Location loc, mlir::FloatType ty, const std::string &s );

        /// Returns a reference to the functionStateMap entry for funcName.
        ///
        /// Create that functionStateMap entry for funcName if it doesn't exist.
        inline ParserPerFunctionState &funcState( const std::string &funcName );

        /// Map INT8_TOKEN, INT16_TOKEN, ... to a mlir::Type
        mlir::Type integerDeclarationType( mlir::Location loc, SillyParser::IntTypeContext *ctx );

        /// Parses scalar type string to MLIR type.
        mlir::Type parseScalarType( const std::string &ty );

        /// Casts value to desired type if needed.
        ///
        /// This is adapted from AssignOpLowering, but uses arith dialect operations instead of LLVM dialect.
        mlir::Value castOpIfRequired( mlir::Location loc, mlir::Value value, mlir::Type desiredType );

        /// Casts index value to index type.
        mlir::Value indexTypeCast( mlir::Location loc, mlir::Value val );

        /// Emits silly::ReturnOp (or exit equivalent) with optional value.
        void processReturnLike( mlir::Location loc, SillyParser::ExpressionContext *rvalueExpression );

        /// For IF/ELIF, create an scf.if condition and set the insertion point to it's then region.
        ///
        /// @param loc [in] The starting location for the IF statement.
        /// @param predicate [in] The predicate for the IF or ELIF condition.
        /// @param saveIP [in] push the insertion point that is effectively after the if to insertionPointStack (use
        /// this for the initial if in an IF/ELIF/ELSE, but not for the internal IF created when processing an ELIF.
        void createIf( mlir::Location loc, SillyParser::ExpressionContext *predicate, bool saveIP );

        /// Find the current scf.if condition and set the insertion point to the else region for that if.
        void selectElseBlock( mlir::Location loc, const std::string &errorText );

        /// Handle assignment processing, given the current var-name and index (if appropriate.)
        void processAssignment( mlir::Location loc, SillyParser::ExpressionContext *exprContext,
                                const std::string &currentVarName, mlir::Value currentIndexExpr );

        /// Handle parsing of an expression (the top-level entry point for expressions).
        /// This function serves as the main entry point for parsing any rvalue expression.
        /// It delegates to the lowest-precedence level (logical OR).
        /// @param ctx The ExpressionContext from the parser (contains expression())
        /// @param ty Type override
        /// @return The MLIR Value representing the parsed expression
        inline mlir::Value parseExpression( SillyParser::ExpressionContext *ctx, mlir::Type ty );

        /// calls parseOr, first actual expression level in the hierarchy
        inline mlir::Value parseLowest( antlr4::ParserRuleContext *ctx, mlir::Type ty );

        /// Parse the logical OR level (lowest precedence binary operator).
        /// Handles expressions of the form: expr OR expr OR expr ...
        /// Left-associative folding. If no OR is present, descends to the AND level.
        /// @param ctx The ExpressionContext (usually ExprLowestContext)
        /// @param ty Type override
        /// @return The resulting Value (typically i1 for logical OR)
        mlir::Value parseOr( antlr4::ParserRuleContext *ctx, mlir::Type ty );

        /// Look for a XorExprContext, and handle it if found.
        mlir::Value parseXor( antlr4::ParserRuleContext *ctx, mlir::Type ty );

        /// Parse the logical AND level.
        /// Handles expressions of the form: term AND term AND term ...
        /// Left-associative. Falls through to equality level if no AND operators are present.
        /// @param ctx BinaryExpressionAndContext from the parser
        /// @param ty type override
        /// @return The resulting Value (typically i1 for logical AND)
        mlir::Value parseAnd( antlr4::ParserRuleContext *ctx, mlir::Type ty );

        /// Parse the equality/inequality level (== and != operators).
        /// Handles expressions of the form: cmp == cmp != cmp ...
        /// Left-associative. Falls through to comparison level if no equality operators.
        /// @param ctx BinaryExpressionCompareContext (may be EqNeExprContext when operators present)
        /// @param ty type override
        /// @return The resulting Value (typically i1 for comparisons)
        mlir::Value parseEquality( antlr4::ParserRuleContext *ctx, mlir::Type ty );

        /// Parse the comparison level (< > <= >=).
        /// Handles expressions of the form: add < add > add <= add ...
        /// Left-associative. Falls through to additive level if no comparison operators.
        /// @param ctx BinaryExpressionCompareContext (CompareExprContext when operators present)
        /// @param ty type override
        /// @return The resulting Value (typically i1)
        mlir::Value parseComparison( antlr4::ParserRuleContext *ctx, mlir::Type ty );

        /// Parse the additive level (+ and - operators).
        /// Handles expressions of the form: mul + mul - mul ...
        /// Left-associative. Falls through to multiplicative level if no +/âˆ’.
        /// @param ctx BinaryExpressionAddSubContext
        /// @param ty type override
        /// @return The resulting Value
        mlir::Value parseAdditive( antlr4::ParserRuleContext *ctx, mlir::Type ty );

        /// Parse the multiplicative level (* and / operators).
        /// Handles expressions of the form: unary * unary / unary ...
        /// Left-associative. Falls through to unary level if no * or /.
        /// @param ctx BinaryExpressionMulDivContext
        /// @param ty type override
        /// @return The resulting Value
        mlir::Value parseMultiplicative( antlr4::ParserRuleContext *ctx, mlir::Type ty );

        /// Parse unary operators (negation, NOT, etc.).
        /// Handles expressions of the form: - unary, NOT unary, or primary.
        /// Right-associative for multiple unaries (e.g., --x).
        /// @param ctx UnaryExpressionContext
        /// @param ty type override
        /// @return The resulting Value
        mlir::Value parseUnary( antlr4::ParserRuleContext *ctx, mlir::Type ty );

        /// Parse primary expressions (literals, variables, calls, parenthesized expressions).
        /// The leaves of the expression tree:
        ///   - literals (integer, float, boolean, string)
        ///   - scalarOrArrayElement (variables or array indexing)
        ///   - callExpression (function calls)
        ///   - ( expression )   parenthesized sub-expressions
        /// @param ctx PrimaryExpressionContext
        /// @param ty type override
        /// @return The resulting Value
        mlir::Value parsePrimary( antlr4::ParserRuleContext *ctx, mlir::Type ty );
    };
}    // namespace silly

// vim: et ts=4 sw=4
