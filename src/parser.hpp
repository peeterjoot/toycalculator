/// @file parser.hpp
/// @author Peeter Joot <peeterjoot@pm.me>
/// @brief Antlr4 based Listener and MLIR builder for the silly compiler.
///
/// This class processes the parse tree generated by the Silly grammar, building
/// corresponding MLIR operations in the Silly dialect. It tracks variable states
/// per function, handles scoping, control flow (if/for), declarations, assignments,
/// function calls, and built-in operations (print/get/exit/return).
#pragma once
#include <antlr4-runtime.h>
#include <mlir/Dialect/Func/IR/FuncOps.h>
#include <mlir/IR/Builders.h>
#include <mlir/IR/BuiltinOps.h>
#include <mlir/IR/MLIRContext.h>

#include <format>
#include <map>
#include <string>
#include <unordered_map>

#include "SillyBaseListener.h"
#include "SillyDialect.hpp"
#include "SillyExceptions.hpp"

namespace silly
{

    /// State of a variable within a function scope.
    enum class VariableState : int
    {
        /// Variable not yet seen in this function.
        undeclared,

        /// Variable declared but not assigned.
        declared,

        /// Variable has been assigned a value.
        assigned
    };

    /// Surface a user error.
    class UserError : public std::exception
    {
       public:
        UserError( mlir::Location iloc, const std::string &imessage ) : loc{ iloc }, message{ imessage }
        {
        }

        /// Fetch the message text from the throw point.
        const char *what() const noexcept override
        {
            return message.c_str();
        }

        mlir::Location getLocation() const
        {
            return loc;
        }

       private:
        mlir::Location loc;
        std::string message;
    };

    /// Context for MLIR dialect registration.
    class DialectCtx
    {
       public:
        /// MLIR context with loaded dialects.
        mlir::MLIRContext context;

        /// Loads required dialects (Silly, Func, Arith, MemRef, LLVM, SCF).
        DialectCtx();
    };

    /// antlr4::tree::TerminalNode is a long winded expression
    using tNode = antlr4::tree::TerminalNode;

    /// Per-function state tracked during parsing.
    struct PerFunctionState
    {
        /// Variable states in this function.
        std::unordered_map<std::string, VariableState> varStates;

        /// Associated func::FuncOp.
        mlir::Operation *funcOp{};

        PerFunctionState()
        {
        }
    };

    using LocPairs = std::pair<mlir::Location, mlir::Location>;

    /// ANTLR listener that constructs MLIR for the Silly language.
    ///
    /// Inherits from SillyBaseListener and BaseErrorListener to process parse tree
    /// events and report syntax errors. Builds a ModuleOp containing FuncOps
    /// with Silly dialect operations.
    class MLIRListener : public SillyBaseListener, public antlr4::BaseErrorListener
    {
       public:
        /// Constructor.
        /// @param filenameIn Source filename for location information.
        MLIRListener( const std::string &filenameIn );

        /// Override to throw on syntax errors.
        void syntaxError( antlr4::Recognizer *recognizer, antlr4::Token *offendingSymbol, size_t line,
                          size_t charPositionInLine, const std::string &msg, std::exception_ptr e ) override;

        void enterStartRule( SillyParser::StartRuleContext *ctx ) override;
        void exitStartRule( SillyParser::StartRuleContext *ctx ) override;

        void enterIfStatement( SillyParser::IfStatementContext *ctx ) override;
        void enterElifStatement( SillyParser::ElifStatementContext *ctx ) override;
        void enterElseStatement( SillyParser::ElseStatementContext *ctx ) override;
        void exitIfelifelse( SillyParser::IfelifelseContext *ctx ) override;

        void enterFunction( SillyParser::FunctionContext *ctx ) override;
        void enterCallStatement( SillyParser::CallStatementContext *ctx ) override;
        void exitFunction( SillyParser::FunctionContext *ctx ) override;
        void enterReturnStatement( SillyParser::ReturnStatementContext *ctx ) override;
        void enterDeclare( SillyParser::DeclareContext *ctx ) override;
        void enterBoolDeclare( SillyParser::BoolDeclareContext *ctx ) override;
        void enterIntDeclare( SillyParser::IntDeclareContext *ctx ) override;
        void enterFloatDeclare( SillyParser::FloatDeclareContext *ctx ) override;
        void enterStringDeclare( SillyParser::StringDeclareContext *ctx ) override;
        void enterPrint( SillyParser::PrintContext *ctx ) override;
        void enterError(SillyParser::ErrorContext * ctx ) override;
        void enterAbort(SillyParser::AbortContext * ctx ) override;
        void enterGet( SillyParser::GetContext *ctx ) override;
        void enterFor( SillyParser::ForContext *ctx ) override;
        void exitFor( SillyParser::ForContext *ctx ) override;
        void enterAssignment( SillyParser::AssignmentContext *ctx ) override;
        void enterExitStatement( SillyParser::ExitStatementContext *ctx ) override;

        /// Returns the constructed ModuleOp.
        /// @throw ExceptionWithContext if syntax errors occurred.
        inline mlir::ModuleOp &getModule();

       private:
        /// Source filename.
        std::string filename;

        /// Dialect context.
        DialectCtx dialect;

        /// MLIR builder.
        mlir::OpBuilder builder;

        /// Current function name.
        std::string currentFuncName;

        /// Stack for scf.if/scf.for blocks.
        std::vector<mlir::OpBuilder::InsertPoint> insertionPointStack;

        /// Top-level module.
        mlir::ModuleOp mod;

        /// Per-function state map.
        std::unordered_map<std::string, std::unique_ptr<PerFunctionState>> functionStateMap;

        /// Syntax errors detected.
        bool hasErrors{};

        // convenience types, so that get calls aren't needed all over the place

        /// i1 type.
        mlir::IntegerType tyI1;

        /// i8 type.
        mlir::IntegerType tyI8;

        /// i16 type.
        mlir::IntegerType tyI16;

        /// i32 type.
        mlir::IntegerType tyI32;

        /// i64 type.
        mlir::IntegerType tyI64;

        /// f32 type.
        mlir::FloatType tyF32;

        /// f64 type.
        mlir::FloatType tyF64;

        /// LLVM pointer type.
        mlir::LLVM::LLVMPointerType tyPtr;

        /// LLVM void type.
        mlir::LLVM::LLVMVoidType tyVoid;

        /// Saved insertion point for main.
        mlir::OpBuilder::InsertPoint mainIP;

        ////////////////////////////////////////////////////////////////////////
        ///
        /// Helper functions
        ///
        ////////////////////////////////////////////////////////////////////////

        /// Looks up DeclareOp for a variable.
        silly::DeclareOp lookupDeclareForVar( mlir::Location loc, const std::string &varName );

        /// Construct locations from the getStart() and getStop() tokens.
        /// Side effect: Creates a silly::ScopeOp for main, if not already done.
        inline LocPairs getLocations( antlr4::ParserRuleContext *ctx );

        /// Computes start location from parser context.
        /// Side effect: Creates a silly::ScopeOp for main, if not already done.
        inline mlir::Location getStartLocation( antlr4::ParserRuleContext *ctx );

        /// Computes stop location from parser context.
        /// Side effect: Creates a silly::ScopeOp for main, if not already done.
        inline mlir::Location getStopLocation( antlr4::ParserRuleContext *ctx );

        /// Strip double quotes off of a string.
        inline std::string stripQuotes( mlir::Location loc, const std::string &input ) const;

        /// Creates a silly::ScopeOp and initializes function state.
        void createScope( mlir::Location startLoc, mlir::Location endLoc, mlir::func::FuncOp func,
                          const std::string &funcName, const std::vector<std::string> &paramNames );

        /// Formats location for error messages.
        inline std::string formatLocation( mlir::Location loc ) const;

        /// Builds MLIR value from unary expression (literals/variables).
        mlir::Value buildUnaryExpression( mlir::Location loc, tNode *booleanNode, tNode *integerNode, tNode *floatNode,
                                          SillyParser::ScalarOrArrayElementContext *scalarOrArrayElement,
                                          SillyParser::CallExpressionContext *callNode, tNode *stringNode,
                                          std::string &s );

        /// Like buildUnaryExpression, but throws an error if a string literal was found.
        mlir::Value buildNonStringUnaryExpression( mlir::Location loc, tNode *booleanNode, tNode *integerNode,
                                                   tNode *floatNode,
                                                   SillyParser::ScalarOrArrayElementContext *scalarOrArrayElement,
                                                   SillyParser::CallExpressionContext *callNode, tNode *stringNode );


        /// Emits a silly::CallOp for a function call.
        mlir::Value handleCall( SillyParser::CallExpressionContext *ctx );

        void handlePrint( mlir::Location loc, const std::vector<SillyParser::PrintArgumentContext *> & args, const std::string & errorContextString, bool error );

        /// Registers a variable declaration in the current scope.
        void registerDeclaration( mlir::Location loc, const std::string &varName, mlir::Type ty,
                                  SillyParser::ArrayBoundsExpressionContext *arrayBounds );

        /// Returns a reference to the functionStateMap entry for funcName.
        ///
        /// Create that functionStateMap entry for funcName if it doesn't exist.
        inline PerFunctionState &funcState( const std::string &funcName );

        /// Set the currentFuncName, and it's corresponding func.func operation.
        inline void setFuncNameAndOp( const std::string &funcName, mlir::Operation *op );

        /// Return the funcOp cached for the current function in setFuncNameAndOp.
        inline mlir::func::FuncOp getFuncOp( mlir::Location loc, const std::string &funcName );

        /// Look up the PerFunctionState for the named function, and set the supplied VariableState for the named
        /// variable.
        inline void setVarState( const std::string &funcName, const std::string &varName, VariableState st );

        /// For currentFuncName, obtain a variable state last saved in a call to setVarState.
        inline VariableState getVarState( const std::string &varName );

        /// Parses scalar type string to MLIR type.
        mlir::Type parseScalarType( const std::string &ty );

        /// Casts value to desired type if needed.
        ///
        /// This is adapted from AssignOpLowering, but uses arith dialect operations instead of LLVM dialect.
        mlir::Value castOpIfRequired( mlir::Location loc, mlir::Value value, mlir::Type desiredType );

        /// Builds i1 predicate from booleanValue context.
        mlir::Value parsePredicate( mlir::Location loc, SillyParser::BooleanValueContext *ctx );

        /// Casts index value to index type.
        mlir::Value indexTypeCast( mlir::Location loc, mlir::Value val );

        /// Finds enclosing silly::ScopeOp.
        silly::ScopeOp getEnclosingScopeOp( mlir::Location loc, mlir::func::FuncOp funcOp ) const;

        /// Emits silly::ReturnOp (or exit equivalent) with optional value.
        void processReturnLike( mlir::Location loc, SillyParser::RvalueExpressionContext *rvalueExpression );

        /// For IF/ELIF, create an scf.if condition and set the insertion point to it's then region.
        ///
        /// @param loc [in] The starting location for the IF statement.
        /// @param booleanValue [in] The predicate for the IF or ELIF condition.
        /// @param saveIP [in] push the insertion point that is effectively after the if to insertionPointStack (use
        /// this for the initial if in an IF/ELIF/ELSE, but not for the internal IF created when processing an ELIF.
        void createIf( mlir::Location loc, SillyParser::BooleanValueContext *booleanValue, bool saveIP );

        /// Find the current scf.if condition and set the insertion point to the else region for that if.
        void selectElseBlock( mlir::Location loc, const std::string &errorText );

        /// Handle parsing of a RvalueExpressionContext, returning an mlir::Value
        mlir::Value parseRvalue( mlir::Location loc, SillyParser::RvalueExpressionContext *ctx, mlir::Type opType,
                                 bool &foundStringLiteral );

        /// Handle parsing of a RvalueExpressionContext, returning an mlir::Value -- but only for the no-string-literal case.
        mlir::Value parseNoStringRvalue( mlir::Location loc, SillyParser::RvalueExpressionContext *ctx, mlir::Type opType );

        /// Handle assignment processing, given the current var-name and index (if appropriate.)
        void processAssignment( mlir::Location loc, SillyParser::RvalueExpressionContext *exprContext,
                                const std::string &currentVarName, mlir::Value currentIndexExpr );
    };

    inline mlir::ModuleOp &MLIRListener::getModule()
    {
        if ( hasErrors )
        {
            throw ExceptionWithContext( __FILE__, __LINE__, __func__,
                                        std::format( "Cannot emit MLIR due to syntax errors in {}", filename ) );
        }
        return mod;
    }
}    // namespace silly

// vim: et ts=4 sw=4
