/// @file parser.hpp
/// @author Peeter Joot <peeterjoot@pm.me>
/// @brief Antlr4 based Listener and MLIR builder for the silly compiler.
///
/// This class processes the parse tree generated by the Silly grammar, building
/// corresponding MLIR operations in the Silly dialect. It tracks variable states
/// per function, handles scoping, control flow (if/for), declarations, assignments,
/// function calls, and built-in operations (print/get/exit/return).
#pragma once
#include <antlr4-runtime.h>
#include <mlir/Dialect/Func/IR/FuncOps.h>
#include <mlir/IR/Builders.h>
#include <mlir/IR/BuiltinOps.h>
#include <mlir/IR/MLIRContext.h>

#include <format>
#include <map>
#include <string>
#include <unordered_map>

#include "SillyBaseListener.h"
#include "SillyDialect.hpp"
#include "SillyExceptions.hpp"
#include "printflags.hpp"

namespace silly
{
    /// Finds enclosing silly::ScopeOp.
    silly::ScopeOp getEnclosingScopeOp( mlir::Location loc, mlir::func::FuncOp funcOp );

    /// Formats location for error messages.
    inline std::string formatLocation( mlir::Location loc );

    /// Surface a user error.
    class UserError : public std::exception
    {
       public:
        UserError( mlir::Location iloc, const std::string &imessage ) : loc{ iloc }, message{ imessage }
        {
        }

        /// Fetch the message text from the throw point.
        const char *what() const noexcept override
        {
            return message.c_str();
        }

        mlir::Location getLocation() const
        {
            return loc;
        }

       private:
        mlir::Location loc;
        std::string message;
    };

    /// Context for MLIR dialect registration.
    class DialectCtx
    {
       public:
        /// MLIR context with loaded dialects.
        mlir::MLIRContext context;

        /// Loads required dialects (Silly, Func, Arith, MemRef, LLVM, SCF).
        DialectCtx();
    };

    /// antlr4::tree::TerminalNode is a long winded expression
    using tNode = antlr4::tree::TerminalNode;

    /// Per-function state tracked during parsing.
    class PerFunctionState
    {
       public:
        mlir::Operation *lastDeclareOp{};

        // Getter and setter for op, just to hide the casting
        mlir::func::FuncOp getFuncOp()
        {
            mlir::func::FuncOp funcOp = mlir::cast<mlir::func::FuncOp>( op );

            return funcOp;
        }

        void setFuncOp( mlir::Operation *funcOp )
        {
            op = funcOp;
        }

       private:
        /// Associated func::FuncOp.
        mlir::Operation *op{};
    };

    using LocPairs = std::pair<mlir::Location, mlir::Location>;

    /// ANTLR listener that constructs MLIR for the Silly language.
    ///
    /// Inherits from SillyBaseListener and BaseErrorListener to process parse tree
    /// events and report syntax errors. Builds a ModuleOp containing FuncOps
    /// with Silly dialect operations.
    class ParseListener : public SillyBaseListener, public antlr4::BaseErrorListener
    {
       public:
        /// Constructor.
        /// @param filenameIn Source filename for location information.
        ParseListener( const std::string &filenameIn );

        /// Override to throw on syntax errors.
        void syntaxError( antlr4::Recognizer *recognizer, antlr4::Token *offendingSymbol, size_t line,
                          size_t charPositionInLine, const std::string &msg, std::exception_ptr e ) override;

        void enterStartRule( SillyParser::StartRuleContext *ctx ) override;
        void exitStartRule( SillyParser::StartRuleContext *ctx ) override;

        void enterIfStatement( SillyParser::IfStatementContext *ctx ) override;
        void enterElifStatement( SillyParser::ElifStatementContext *ctx ) override;
        void enterElseStatement( SillyParser::ElseStatementContext *ctx ) override;
        void exitIfElifElseStatement( SillyParser::IfElifElseStatementContext *ctx ) override;

        void enterFunctionStatement( SillyParser::FunctionStatementContext *ctx ) override;
        void enterCallStatement( SillyParser::CallStatementContext *ctx ) override;
        void exitFunctionStatement( SillyParser::FunctionStatementContext *ctx ) override;
        void enterReturnStatement( SillyParser::ReturnStatementContext *ctx ) override;
        void enterDeclareStatement( SillyParser::DeclareStatementContext *ctx ) override;
        void enterBoolDeclareStatement( SillyParser::BoolDeclareStatementContext *ctx ) override;
        void enterIntDeclareStatement( SillyParser::IntDeclareStatementContext *ctx ) override;
        void enterFloatDeclareStatement( SillyParser::FloatDeclareStatementContext *ctx ) override;
        void enterStringDeclareStatement( SillyParser::StringDeclareStatementContext *ctx ) override;
        void enterPrintStatement( SillyParser::PrintStatementContext *ctx ) override;
        void enterErrorStatement( SillyParser::ErrorStatementContext *ctx ) override;
        void enterAbortStatement( SillyParser::AbortStatementContext *ctx ) override;
        void enterGetStatement( SillyParser::GetStatementContext *ctx ) override;
        void enterForStatement( SillyParser::ForStatementContext *ctx ) override;
        void exitForStatement( SillyParser::ForStatementContext *ctx ) override;
        void enterAssignmentStatement( SillyParser::AssignmentStatementContext *ctx ) override;
        void enterExitStatement( SillyParser::ExitStatementContext *ctx ) override;

        /// Returns the constructed ModuleOp.
        /// @throw ExceptionWithContext if syntax errors occurred.
        inline mlir::ModuleOp &getModule();

       private:
        /// Source filename.
        std::string filename;

        /// Dialect context.
        DialectCtx dialect;

        /// MLIR builder.
        mlir::OpBuilder builder;

        /// Current function name.
        std::string currentFuncName;

        /// Stack for scf.if/scf.for blocks.
        std::vector<mlir::OpBuilder::InsertPoint> insertionPointStack;

        /// Top-level module.
        mlir::ModuleOp mod;

        /// Per-function state map.
        std::unordered_map<std::string, std::unique_ptr<PerFunctionState>> functionStateMap;

        /// Syntax errors detected.
        bool hasErrors{};

        // convenience types, so that get calls aren't needed all over the place

        /// i1 type.
        mlir::IntegerType tyI1;

        /// i8 type.
        mlir::IntegerType tyI8;

        /// i16 type.
        mlir::IntegerType tyI16;

        /// i32 type.
        mlir::IntegerType tyI32;

        /// i64 type.
        mlir::IntegerType tyI64;

        /// f32 type.
        mlir::FloatType tyF32;

        /// f64 type.
        mlir::FloatType tyF64;

        /// LLVM pointer type.
        mlir::LLVM::LLVMPointerType tyPtr;

        /// LLVM void type.
        mlir::LLVM::LLVMVoidType tyVoid;

        /// Saved insertion point for main.
        mlir::OpBuilder::InsertPoint mainIP;

        ////////////////////////////////////////////////////////////////////////
        ///
        /// Helper functions
        ///
        ////////////////////////////////////////////////////////////////////////

        void enterDeclareHelper( mlir::Location loc, tNode *identifier,
                                 SillyParser::DeclareAssignmentExpressionContext *declareAssignmentExpression,
                                 const std::vector<SillyParser::ExpressionContext *> &expressions, tNode *hasInitList,
                                 SillyParser::ArrayBoundsExpressionContext *arrayBoundsExpression, mlir::Type ty );

        /// Looks up DeclareOp for a variable.
        silly::DeclareOp lookupDeclareForVar( mlir::Location loc, const std::string &varName );

        /// Construct locations from the getStart() and getStop() tokens.
        /// Side effect: Creates a silly::ScopeOp for main, if not already done.
        inline LocPairs getLocations( antlr4::ParserRuleContext *ctx );

        /// Computes start location from parser context.
        /// Side effect: Creates a silly::ScopeOp for main, if not already done.
        inline mlir::Location getStartLocation( antlr4::ParserRuleContext *ctx );

        /// Computes stop location from parser context.
        /// Side effect: Creates a silly::ScopeOp for main, if not already done.
        inline mlir::Location getStopLocation( antlr4::ParserRuleContext *ctx );

        /// Strip double quotes off of a string.
        inline std::string stripQuotes( mlir::Location loc, const std::string &input ) const;

        /// Creates a silly::ScopeOp and initializes function state.
        void createScope( mlir::Location startLoc, mlir::Location endLoc, mlir::func::FuncOp func,
                          const std::string &funcName, const std::vector<std::string> &paramNames );

        /// Emits a silly::CallOp for a function call.
        mlir::Value handleCall( SillyParser::CallExpressionContext *ctx );

        /// builder logic for print arguments (shared between PRINT and ERROR.)
        void handlePrint( mlir::Location loc, const std::vector<SillyParser::ExpressionContext *> &args,
                          const std::string &errorContextString, PrintFlags flags );

        /// Registers a variable declaration in the current scope.
        void registerDeclaration( mlir::Location loc, const std::string &varName, mlir::Type ty,
                                  SillyParser::ArrayBoundsExpressionContext *arrayBounds,
                                  SillyParser::ExpressionContext *assignmentExpression,
                                  const std::vector<SillyParser::ExpressionContext *> *expressions );

        /// Return true if the variable is declared
        bool isVariableDeclared( mlir::Location loc, const std::string &varName );

        /// Construct a Value for a TRUE or FALSE boolean literal string
        inline mlir::Value parseBoolean( mlir::Location loc, const std::string &s );

        /// Construct a Value for an integer literal string
        inline mlir::Value parseInteger( mlir::Location loc, int width, const std::string &s );

        /// Construct a Value for a floating point literal string
        inline mlir::Value parseFloat( mlir::Location loc, mlir::FloatType ty, const std::string &s );

        /// Returns a reference to the functionStateMap entry for funcName.
        ///
        /// Create that functionStateMap entry for funcName if it doesn't exist.
        inline PerFunctionState &funcState( const std::string &funcName );

        /// Parses scalar type string to MLIR type.
        mlir::Type parseScalarType( const std::string &ty );

        /// Casts value to desired type if needed.
        ///
        /// This is adapted from AssignOpLowering, but uses arith dialect operations instead of LLVM dialect.
        mlir::Value castOpIfRequired( mlir::Location loc, mlir::Value value, mlir::Type desiredType );

        /// Figure out the bigger of two types for implicit cast-like purposes
        static mlir::Type biggestTypeOf( mlir::Type ty1, mlir::Type ty2 );

        /// Casts index value to index type.
        mlir::Value indexTypeCast( mlir::Location loc, mlir::Value val );

        /// Emits silly::ReturnOp (or exit equivalent) with optional value.
        void processReturnLike( mlir::Location loc, SillyParser::ExpressionContext *rvalueExpression );

        /// For IF/ELIF, create an scf.if condition and set the insertion point to it's then region.
        ///
        /// @param loc [in] The starting location for the IF statement.
        /// @param predicate [in] The predicate for the IF or ELIF condition.
        /// @param saveIP [in] push the insertion point that is effectively after the if to insertionPointStack (use
        /// this for the initial if in an IF/ELIF/ELSE, but not for the internal IF created when processing an ELIF.
        void createIf( mlir::Location loc, SillyParser::ExpressionContext *predicate, bool saveIP );

        /// Find the current scf.if condition and set the insertion point to the else region for that if.
        void selectElseBlock( mlir::Location loc, const std::string &errorText );

        /// Handle parsing of an expression (the top-level entry point for expressions).
        /// This function serves as the main entry point for parsing any rvalue expression.
        /// It delegates to the lowest-precedence level (logical OR).
        /// @param ctx The ExpressionContext from the parser (contains expression())
        /// @return The MLIR Value representing the parsed expression
        inline mlir::Value parseExpression( SillyParser::ExpressionContext *ctx, mlir::Type ty );

        // calls parseOr, first actual expression level in the hierarchy
        inline mlir::Value parseLowest( antlr4::ParserRuleContext *ctx );

        /// Parse the logical OR level (lowest precedence binary operator).
        /// Handles expressions of the form: expr OR expr OR expr ...
        /// Left-associative folding. If no OR is present, descends to the AND level.
        /// @param ctx The ExpressionContext (usually ExprLowestContext)
        /// @return The resulting Value (typically i1 for logical OR)
        mlir::Value parseOr( antlr4::ParserRuleContext *ctx );

        mlir::Value parseXor( antlr4::ParserRuleContext *ctx );

        /// Parse the logical AND level.
        /// Handles expressions of the form: term AND term AND term ...
        /// Left-associative. Falls through to equality level if no AND operators are present.
        /// @param ctx BinaryExpressionAndContext from the parser
        /// @return The resulting Value (typically i1 for logical AND)
        mlir::Value parseAnd( antlr4::ParserRuleContext *ctx );

        /// Parse the equality/inequality level (== and != operators).
        /// Handles expressions of the form: cmp == cmp != cmp ...
        /// Left-associative. Falls through to comparison level if no equality operators.
        /// @param ctx BinaryExpressionCompareContext (may be EqNeExprContext when operators present)
        /// @return The resulting Value (typically i1 for comparisons)
        mlir::Value parseEquality( antlr4::ParserRuleContext *ctx );

        /// Parse the comparison level (< > <= >=).
        /// Handles expressions of the form: add < add > add <= add ...
        /// Left-associative. Falls through to additive level if no comparison operators.
        /// @param ctx BinaryExpressionCompareContext (CompareExprContext when operators present)
        /// @return The resulting Value (typically i1)
        mlir::Value parseComparison( antlr4::ParserRuleContext *ctx );

        /// Parse the additive level (+ and - operators).
        /// Handles expressions of the form: mul + mul - mul ...
        /// Left-associative. Falls through to multiplicative level if no +/âˆ’.
        /// @param ctx BinaryExpressionAddSubContext
        /// @return The resulting Value
        mlir::Value parseAdditive( antlr4::ParserRuleContext *ctx );

        /// Parse the multiplicative level (* and / operators).
        /// Handles expressions of the form: unary * unary / unary ...
        /// Left-associative. Falls through to unary level if no * or /.
        /// @param ctx BinaryExpressionMulDivContext
        /// @return The resulting Value
        mlir::Value parseMultiplicative( antlr4::ParserRuleContext *ctx );

        /// Parse unary operators (negation, NOT, etc.).
        /// Handles expressions of the form: - unary, NOT unary, or primary.
        /// Right-associative for multiple unaries (e.g., --x).
        /// @param ctx UnaryExpressionContext
        /// @return The resulting Value
        mlir::Value parseUnary( antlr4::ParserRuleContext *ctx );

        /// Parse primary expressions (literals, variables, calls, parenthesized expressions).
        /// The leaves of the expression tree:
        ///   - literals (integer, float, boolean, string)
        ///   - scalarOrArrayElement (variables or array indexing)
        ///   - callExpression (function calls)
        ///   - ( expression )   parenthesized sub-expressions
        /// @param ctx PrimaryExpressionContext
        /// @return The resulting Value
        mlir::Value parsePrimary( antlr4::ParserRuleContext *ctx );

        /// Handle assignment processing, given the current var-name and index (if appropriate.)
        void processAssignment( mlir::Location loc, SillyParser::ExpressionContext *exprContext,
                                const std::string &currentVarName, mlir::Value currentIndexExpr );
    };

    inline mlir::ModuleOp &ParseListener::getModule()
    {
        if ( hasErrors )
        {
            throw ExceptionWithContext( __FILE__, __LINE__, __func__,
                                        std::format( "Cannot emit MLIR due to syntax errors in {}", filename ) );
        }
        return mod;
    }
}    // namespace silly

// vim: et ts=4 sw=4
