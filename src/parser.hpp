/**
 * @file parser.hpp
 * @author Peeter Joot <peeterjoot@pm.me>
 * @brief Antlr4 based Listener and MLIR builder for the toy (calculator) compiler.
 *
 * This class processes the parse tree generated by the Toy grammar, building
 * corresponding MLIR operations in the Toy dialect. It tracks variable states
 * per function, handles scoping, control flow (if/for), declarations, assignments,
 * function calls, and built-in operations (print/get/exit/return).
 */
#pragma once

#include <antlr4-runtime.h>
#include <mlir/Dialect/Func/IR/FuncOps.h>
#include <mlir/IR/Builders.h>
#include <mlir/IR/BuiltinOps.h>
#include <mlir/IR/MLIRContext.h>

#include <format>
#include <map>
#include <string>
#include <unordered_map>

#include "ToyBaseListener.h"
#include "ToyDialect.hpp"
#include "ToyExceptions.hpp"

namespace toy
{
    /**
     * @brief State of a variable within a function scope.
     */
    enum class variable_state : int
    {
        undeclared,    ///< Variable not yet seen in this function.
        declared,      ///< Variable declared but not assigned.
        assigned       ///< Variable has been assigned a value.
    };

    /**
     * @brief Context for MLIR dialect registration.
     */
    class DialectCtx
    {
       public:
        mlir::MLIRContext context;    ///< MLIR context with loaded dialects.
        DialectCtx();                 ///< Loads required dialects (Toy, Func, Arith, MemRef, LLVM, SCF).
    };

    using tNode = antlr4::tree::TerminalNode;

    /**
     * @brief Per-function state tracked during parsing.
     */
    struct PerFunctionState
    {
        std::unordered_map<std::string, variable_state> varStates;    ///< Variable states in this function.
        mlir::Operation *funcOp{};                                    ///< Associated func::FuncOp.
        mlir::Location lastLoc;                                       ///< Last location seen in this function.
        bool terminatorWasExplcit{};                                  ///< True if return/exit was explicit.

        PerFunctionState( mlir::Location loc ) : lastLoc( loc )
        {
        }
    };

    /**
     * @brief ANTLR listener that constructs MLIR for the Toy language.
     *
     * Inherits from ToyBaseListener and BaseErrorListener to process parse tree
     * events and report syntax errors. Builds a ModuleOp containing FuncOps
     * with Toy dialect operations.
     */
    class MLIRListener : public ToyBaseListener, public antlr4::BaseErrorListener
    {
       public:
        /**
         * @brief Constructor.
         * @param _filename Source filename for location information.
         */
        MLIRListener( const std::string &_filename );

        /**
         * @brief Override to throw on syntax errors.
         */
        void syntaxError( antlr4::Recognizer *recognizer, antlr4::Token *offendingSymbol, size_t line,
                          size_t charPositionInLine, const std::string &msg, std::exception_ptr e ) override;

        void enterStartRule( ToyParser::StartRuleContext *ctx ) override;
        void exitStartRule( ToyParser::StartRuleContext *ctx ) override;
        void exitIfStatement( ToyParser::IfStatementContext *ctx ) override;
        void exitElseStatement( ToyParser::ElseStatementContext *ctx ) override;

        /**
         * @brief Creates main function scope on first use.
         */
        void mainFirstTime( mlir::Location loc );

        void enterIfelifelse( ToyParser::IfelifelseContext *ctx ) override;
        void enterFunction( ToyParser::FunctionContext *ctx ) override;
        void enterCall( ToyParser::CallContext *ctx ) override;
        void exitFunction( ToyParser::FunctionContext *ctx ) override;
        void enterReturnStatement( ToyParser::ReturnStatementContext *ctx ) override;
        void enterDeclare( ToyParser::DeclareContext *ctx ) override;
        void enterBoolDeclare( ToyParser::BoolDeclareContext *ctx ) override;
        void enterIntDeclare( ToyParser::IntDeclareContext *ctx ) override;
        void enterFloatDeclare( ToyParser::FloatDeclareContext *ctx ) override;
        void enterStringDeclare( ToyParser::StringDeclareContext *ctx ) override;
        void enterPrint( ToyParser::PrintContext *ctx ) override;
        void enterGet( ToyParser::GetContext *ctx ) override;
        void enterFor( ToyParser::ForContext *ctx ) override;
        void exitFor( ToyParser::ForContext *ctx ) override;
        void enterAssignment( ToyParser::AssignmentContext *ctx ) override;
        void exitAssignment( ToyParser::AssignmentContext *ctx ) override;
        void enterExitStatement( ToyParser::ExitStatementContext *ctx ) override;
        void enterRhs( ToyParser::RhsContext *ctx ) override;

        /**
         * @brief Returns the constructed ModuleOp.
         * @throw exception_with_context if syntax errors occurred.
         */
        inline mlir::ModuleOp &getModule();

       private:
        std::string filename;                                             ///< Source filename.
        DialectCtx dialect;                                               ///< Dialect context.
        mlir::OpBuilder builder;                                          ///< MLIR builder.
        mlir::Location currentAssignLoc;                                  ///< Location of current assignment.
        std::string currentFuncName;                                      ///< Current function name.
        mlir::FileLineColLoc lastLocation;                                ///< Cached last location.
        std::vector<mlir::OpBuilder::InsertPoint> insertionPointStack;    ///< Stack for scf.if/scf.for blocks.
        mlir::ModuleOp mod;                                               ///< Top-level module.
        std::string currentVarName;                                       ///< Variable name in current assignment.
        mlir::Value currentIndexExpr;                                     ///< Index expression in current assignment.
        std::unordered_map<std::string, std::unique_ptr<PerFunctionState>> pr_funcState;    ///< Per-function state map.
        bool assignmentTargetValid{};           ///< Valid assignment target.
        bool hasErrors{};                       ///< Syntax errors detected.

        // convienence types, so that get calls aren't needed all over the place
        mlir::IntegerType tyI1;                 ///< i1 type.
        mlir::IntegerType tyI8;                 ///< i8 type.
        mlir::IntegerType tyI16;                ///< i16 type.
        mlir::IntegerType tyI32;                ///< i32 type.
        mlir::IntegerType tyI64;                ///< i64 type.
        mlir::FloatType tyF32;                  ///< f32 type.
        mlir::FloatType tyF64;                  ///< f64 type.
        mlir::LLVM::LLVMPointerType tyPtr;      ///< LLVM pointer type.
        mlir::LLVM::LLVMVoidType tyVoid;        ///< LLVM void type.

        mlir::OpBuilder::InsertPoint mainIP;    ///< Saved insertion point for main.
        bool callIsHandled{};                   ///< Call handled in RHS.
        bool mainScopeGenerated{};              ///< Main scope created.

        /**
         * @brief Looks up DeclareOp for a variable.
         */
        toy::DeclareOp lookupDeclareForVar( mlir::Location loc, const std::string &varName );

        /**
         * @brief Computes location from parser context.
         */
        inline mlir::Location getLocation( antlr4::ParserRuleContext *ctx, bool useStopLocation = false );

        /**
         * Strip double quotes off of a string.
         */
        inline std::string stripQuotes( mlir::Location loc, const std::string &input ) const;

        /**
         * @brief Creates a toy::ScopeOp and initializes function state.
         */
        void createScope( mlir::Location loc, mlir::func::FuncOp func, const std::string &funcName,
                          const std::vector<std::string> &paramNames );

        /**
         * @brief Formats location for error messages.
         */
        inline std::string formatLocation( mlir::Location loc ) const;

        /**
         * @brief Builds MLIR value from unary expression (literals/variables).
         */
        mlir::Value buildUnaryExpression( mlir::Location loc, tNode *booleanNode, tNode *integerNode, tNode *floatNode,
                                   ToyParser::ScalarOrArrayElementContext *scalarOrArrayElement, tNode *stringNode,
                                   std::string &s );

        mlir::Value buildNonStringUnaryExpression( mlir::Location loc, tNode *booleanNode, tNode *integerNode, tNode *floatNode,
                                            ToyParser::ScalarOrArrayElementContext *scalarOrArrayElement, tNode *stringNode );

        /**
         * @brief Emits a toy::CallOp for a function call.
         */
        mlir::Value handleCall( ToyParser::CallContext *ctx );

        /**
         * @brief Registers a variable declaration in the current scope.
         */
        void registerDeclaration( mlir::Location loc, const std::string &varName, mlir::Type ty,
                                  ToyParser::ArrayBoundsExpressionContext *arrayBounds );

        inline PerFunctionState &funcState( const std::string &funcName );
        inline void setVarState( const std::string &funcName, const std::string &varName, variable_state st );
        inline variable_state getVarState( const std::string &varName );
        inline void setFuncOp( mlir::Operation *op );
        inline mlir::func::FuncOp getFuncOp( mlir::Location loc, const std::string &funcName );
        inline void markExplicitTerminator();
        inline bool wasTerminatorExplicit();
        inline void setLastLoc( mlir::Location loc );
        inline mlir::Location getLastLoc();

        /**
         * @brief Parses scalar type string to MLIR type.
         */
        mlir::Type parseScalarType( const std::string &ty );

        /**
         * @brief Casts value to desired type if needed.
         */
        mlir::Value castOpIfRequired( mlir::Location loc, mlir::Value value, mlir::Type desiredType );

        /**
         * @brief Builds i1 predicate from booleanValue context.
         */
        mlir::Value parsePredicate( mlir::Location loc, ToyParser::BooleanValueContext *ctx );

        /**
         * @brief Casts index value to index type.
         */
        mlir::Value indexTypeCast( mlir::Location loc, mlir::Value val );

        /**
         * @brief Finds enclosing toy::ScopeOp.
         */
        toy::ScopeOp getEnclosingScopeOp( mlir::Location loc, mlir::func::FuncOp funcOp ) const;

        /**
         * @brief Emits toy::ReturnOp (or exit equivalent) with optional value.
         */
        template <class Literal>
        void processReturnLike( mlir::Location loc, Literal *lit,
                                ToyParser::ScalarOrArrayElementContext *scalarOrArrayElement, tNode *boolNode );
    };

    inline mlir::ModuleOp &MLIRListener::getModule()
    {
        if ( hasErrors )
        {
            throw exception_with_context( __FILE__, __LINE__, __func__,
                                          std::format( "Cannot emit MLIR due to syntax errors in {}", filename ) );
        }
        return mod;
    }
}    // namespace toy

// vim: et ts=4 sw=4
