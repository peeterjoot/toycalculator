/// @file parser.hpp
/// @author Peeter Joot <peeterjoot@pm.me>
/// @brief Antlr4 based Listener and MLIR builder for the silly compiler.
///
/// This class processes the parse tree generated by the Silly grammar, building
/// corresponding MLIR operations in the Silly dialect. It tracks variable states
/// per function, handles scoping, control flow (if/for), declarations, assignments,
/// function calls, and built-in operations (print/get/exit/return).
#pragma once
#include <antlr4-runtime.h>
#include <mlir/Dialect/Func/IR/FuncOps.h>
#include <mlir/IR/Builders.h>
#include <mlir/IR/BuiltinOps.h>
#include <mlir/IR/MLIRContext.h>

#include <format>
#include <map>
#include <string>
#include <unordered_map>

#include "SillyBaseListener.h"
#include "SillyDialect.hpp"
#include "SillyExceptions.hpp"

namespace silly
{

    /// State of a variable within a function scope.
    enum class VariableState : int
    {
        /// Variable not yet seen in this function.
        undeclared,

        /// Variable declared but not assigned.
        declared,

        /// Variable has been assigned a value.
        assigned
    };

    /// Surface a user error.
    class UserError : public std::exception
    {
       public:
        UserError( mlir::Location iloc, const std::string &imessage ) : loc{ iloc }, message{ imessage }
        {
        }

        /// Fetch the message text from the throw point.
        const char *what() const noexcept override
        {
            return message.c_str();
        }

        mlir::Location getLocation() const
        {
            return loc;
        }

       private:
        mlir::Location loc;
        std::string message;
    };

    /// Context for MLIR dialect registration.
    class DialectCtx
    {
       public:
        /// MLIR context with loaded dialects.
        mlir::MLIRContext context;

        /// Loads required dialects (Silly, Func, Arith, MemRef, LLVM, SCF).
        DialectCtx();
    };

    using tNode = antlr4::tree::TerminalNode;


    /// Per-function state tracked during parsing.
    struct PerFunctionState
    {
        /// Variable states in this function.
        std::unordered_map<std::string, VariableState> varStates;

        /// Associated func::FuncOp.
        mlir::Operation *funcOp{};

        PerFunctionState()
        {
        }
    };

    using LocPairs = std::pair<mlir::Location, mlir::Location>;

    /// ANTLR listener that constructs MLIR for the Silly language.
    ///
    /// Inherits from SillyBaseListener and BaseErrorListener to process parse tree
    /// events and report syntax errors. Builds a ModuleOp containing FuncOps
    /// with Silly dialect operations.
    class MLIRListener : public SillyBaseListener, public antlr4::BaseErrorListener
    {
       public:
        /// Constructor.
        /// @param filenameIn Source filename for location information.
        MLIRListener( const std::string &filenameIn );

        /// Override to throw on syntax errors.
        void syntaxError( antlr4::Recognizer *recognizer, antlr4::Token *offendingSymbol, size_t line,
                          size_t charPositionInLine, const std::string &msg, std::exception_ptr e ) override;

        void enterStartRule( SillyParser::StartRuleContext *ctx ) override;
        void exitStartRule( SillyParser::StartRuleContext *ctx ) override;

        void enterIfStatement( SillyParser::IfStatementContext *ctx ) override;
        void enterElifStatement( SillyParser::ElifStatementContext *ctx ) override;
        void enterElseStatement( SillyParser::ElseStatementContext *ctx ) override;
        void exitIfelifelse( SillyParser::IfelifelseContext *ctx ) override;

        void enterFunction( SillyParser::FunctionContext *ctx ) override;
        void enterCall( SillyParser::CallContext *ctx ) override;
        void exitFunction( SillyParser::FunctionContext *ctx ) override;
        void enterReturnStatement( SillyParser::ReturnStatementContext *ctx ) override;
        void enterDeclare( SillyParser::DeclareContext *ctx ) override;
        void enterBoolDeclare( SillyParser::BoolDeclareContext *ctx ) override;
        void enterIntDeclare( SillyParser::IntDeclareContext *ctx ) override;
        void enterFloatDeclare( SillyParser::FloatDeclareContext *ctx ) override;
        void enterStringDeclare( SillyParser::StringDeclareContext *ctx ) override;
        void enterPrint( SillyParser::PrintContext *ctx ) override;
        void enterGet( SillyParser::GetContext *ctx ) override;
        void enterFor( SillyParser::ForContext *ctx ) override;
        void exitFor( SillyParser::ForContext *ctx ) override;
        void enterAssignment( SillyParser::AssignmentContext *ctx ) override;
        void exitAssignment( SillyParser::AssignmentContext *ctx ) override;
        void enterExitStatement( SillyParser::ExitStatementContext *ctx ) override;
        void enterRvalueExpression( SillyParser::RvalueExpressionContext *ctx ) override;

        /// Returns the constructed ModuleOp.
        /// @throw ExceptionWithContext if syntax errors occurred.
        inline mlir::ModuleOp &getModule();

       private:
        /// Source filename.
        std::string filename;

        /// Dialect context.
        DialectCtx dialect;

        /// MLIR builder.
        mlir::OpBuilder builder;

        /// Location of current assignment.
        mlir::Location currentAssignLoc;

        /// Current function name.
        std::string currentFuncName;

        /// Stack for scf.if/scf.for blocks.
        std::vector<mlir::OpBuilder::InsertPoint> insertionPointStack;

        /// Top-level module.
        mlir::ModuleOp mod;

        /// Variable name in current assignment.
        std::string currentVarName;

        /// Index expression in current assignment.
        mlir::Value currentIndexExpr;

        /// Per-function state map.
        std::unordered_map<std::string, std::unique_ptr<PerFunctionState>> functionStateMap;

        /// Valid assignment target.
        bool assignmentTargetValid{};

        /// Syntax errors detected.
        bool hasErrors{};

        // convenience types, so that get calls aren't needed all over the place

        /// i1 type.
        mlir::IntegerType tyI1;

        /// i8 type.
        mlir::IntegerType tyI8;

        /// i16 type.
        mlir::IntegerType tyI16;

        /// i32 type.
        mlir::IntegerType tyI32;

        /// i64 type.
        mlir::IntegerType tyI64;

        /// f32 type.
        mlir::FloatType tyF32;

        /// f64 type.
        mlir::FloatType tyF64;

        /// LLVM pointer type.
        mlir::LLVM::LLVMPointerType tyPtr;

        /// LLVM void type.
        mlir::LLVM::LLVMVoidType tyVoid;

        /// Saved insertion point for main.
        mlir::OpBuilder::InsertPoint mainIP;

        /// Call handled in RHS.
        bool callIsHandled{};

        /// Main ScopeOp created (symbol table, region, and block)
        bool mainScopeGenerated{};

        /// Looks up DeclareOp for a variable.
        silly::DeclareOp lookupDeclareForVar( mlir::Location loc, const std::string &varName );

        /// Construct locations from the getStart() and getStop() tokens.
        /// Side effect: Creates a silly::ScopeOp for main, if not already done.
        inline LocPairs getLocations( antlr4::ParserRuleContext *ctx );

        /// Computes start location from parser context.
        /// Side effect: Creates a silly::ScopeOp for main, if not already done.
        inline mlir::Location getStartLocation( antlr4::ParserRuleContext *ctx );

        /// Computes stop location from parser context.
        /// Side effect: Creates a silly::ScopeOp for main, if not already done.
        inline mlir::Location getStopLocation( antlr4::ParserRuleContext *ctx );

        /// Strip double quotes off of a string.
        inline std::string stripQuotes( mlir::Location loc, const std::string &input ) const;

        /// Creates a silly::ScopeOp and initializes function state.
        void createScope( mlir::Location startLoc, mlir::Location endLoc, mlir::func::FuncOp func,
                          const std::string &funcName, const std::vector<std::string> &paramNames );

        /// Formats location for error messages.
        inline std::string formatLocation( mlir::Location loc ) const;

        /// Builds MLIR value from unary expression (literals/variables).
        mlir::Value buildUnaryExpression( mlir::Location loc, tNode *booleanNode, tNode *integerNode, tNode *floatNode,
                                          SillyParser::ScalarOrArrayElementContext *scalarOrArrayElement,
                                          tNode *stringNode, std::string &s );

        mlir::Value buildNonStringUnaryExpression( mlir::Location loc, tNode *booleanNode, tNode *integerNode,
                                                   tNode *floatNode,
                                                   SillyParser::ScalarOrArrayElementContext *scalarOrArrayElement,
                                                   tNode *stringNode );


        /// Emits a silly::CallOp for a function call.
        mlir::Value handleCall( SillyParser::CallContext *ctx );


        /// Registers a variable declaration in the current scope.
        void registerDeclaration( mlir::Location loc, const std::string &varName, mlir::Type ty,
                                  SillyParser::ArrayBoundsExpressionContext *arrayBounds );

        inline PerFunctionState &funcState( const std::string &funcName );
        inline void setVarState( const std::string &funcName, const std::string &varName, VariableState st );
        inline VariableState getVarState( const std::string &varName );
        inline void setFuncOp( mlir::Operation *op );
        inline mlir::func::FuncOp getFuncOp( mlir::Location loc, const std::string &funcName );

        /// Parses scalar type string to MLIR type.
        mlir::Type parseScalarType( const std::string &ty );


        /// Casts value to desired type if needed.
        ///
        /// This is adapted from AssignOpLowering, but uses arith dialect operations instead of LLVM dialect.
        mlir::Value castOpIfRequired( mlir::Location loc, mlir::Value value, mlir::Type desiredType );


        /// Builds i1 predicate from booleanValue context.
        mlir::Value parsePredicate( mlir::Location loc, SillyParser::BooleanValueContext *ctx );


        /// Casts index value to index type.
        mlir::Value indexTypeCast( mlir::Location loc, mlir::Value val );


        /// Finds enclosing silly::ScopeOp.
        silly::ScopeOp getEnclosingScopeOp( mlir::Location loc, mlir::func::FuncOp funcOp ) const;


        /// Emits silly::ReturnOp (or exit equivalent) with optional value.
        template <class Literal>
        void processReturnLike( mlir::Location loc, Literal *lit,
                                SillyParser::ScalarOrArrayElementContext *scalarOrArrayElement, tNode *boolNode );


        void createIf( mlir::Location loc, SillyParser::BooleanValueContext *booleanValue, bool saveIP );

        void selectElseBlock( mlir::Location loc, const std::string & errorText );
    };

    inline mlir::ModuleOp &MLIRListener::getModule()
    {
        if ( hasErrors )
        {
            throw ExceptionWithContext( __FILE__, __LINE__, __func__,
                                        std::format( "Cannot emit MLIR due to syntax errors in {}", filename ) );
        }
        return mod;
    }
}    // namespace silly

// vim: et ts=4 sw=4
